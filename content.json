{"pages":[{"title":"About Me","text":"无名之辈","link":"/about/index.html"}],"posts":[{"title":"2020年度总结","text":"2020 年是动荡的一年。不光是宏观的社会因素的层面上，单就我的工作内容来说，也很动荡。 2020 年学习计划大半泡了汤。年初发愿要以最高优先级对待的 StreamingCore 项目也彻底停滞。工作内容跟直播越来越无关，搞得我也没多大心思再去钻研相关技术；还总是犯懒，三天打鱼两天晒网，又喜欢东一锄头西一耙的瞎搞。 上班时…上半年…上半年工作内容集中在 Unity 上，开发 VR 眼镜直播客户端。收获颇丰。 上手了 Unity 开发平台，知道了怎么用 Unity 开发一款 Android APP； 重新捡起 C#。C# 的语法糖一直很香，可惜在 Unity 内应用 C# 还是有很大的局限性，比如 async await 这套还不能用； 对 3D 游戏开发有了初级的实战经验，模型的使用，Draw Call 优化等等。 算是多了条路吧。 但遗憾还是多过收获，下半年这个项目因为没什么用户量被砍掉了，就此也没机会再深入系统地学习 Unity 了。 下半年…下一个项目是我们组自研引擎的可视化编辑器，等于从使用 Unity “提升”到了开发 Unity。我个人并不看好这个立意宏伟的大饼，因为从一开始其投入的人力就不足，一直持续到现在。 好歹工作内容还是我喜欢的，又捡起了 Qt。 架构设计、模块划分是我独立完成的，支撑能力尚可，至今还没遭遇需要大修改的需求。 一些基础组件的技术选型和开发落地也是我完成的，比如打包器、资源管理器。一个很严重的失误就是直接套用了 Qt Property Browser 实现的属性面板。UI 风格定制化能力极差，源码改动很多；自定义属性交互也极其麻烦，很典型的过度设计。 下班时…爬虫搞 Unity 搞的心痒痒，想自己搞个小游戏。什么样的游戏呢？福利游戏吧。就开始了找资源之路。手上一把的 Jav 网站，挑了一个简单、顺眼的开始学写爬虫。写到后来，已经完全忘记了初衷，全心全意地投入到爬虫事业中了。 现在爬虫部署到了我的服务器上，可以多线程操作，可以根据关键字过滤爬取，还可以分门别类爬取。技术学到了，身体也跨了。 视频剪辑器爬下来的 Jav，太大太长，不利于反复温习其中精彩部分，就又开始搞剪辑。 把 FFmpeg 里 format、codec、filter 几个模块 api 的基础用法温习、学习后，封装串联，用 Qt 实现了 UI 交互。 现在已经基本满足了需求，能实现精确到帧到帧的视频截取。 总结的总结…人总说“试试那人的深浅”，没人说“试试那人的宽窄”，可见精深某一领域是更难得的能力。我好像怎么也成不了这种人，且就随遇而安，这么动荡着吧。","link":"/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html"},{"title":"2020 年学习规划","text":"2020年会整体围绕StreamingCore项目运作。先期会先做一部分复习工作，比如C++相关、工程相关；其它所列知识点会边学边应用。 尽量详细地列出各项，不断回顾并更新进度。 理论知识复习C++ 《C++ Primer》 ✅ 《Effective Modern C++》 ❌ 《C++标准库》 ✅ 《Effective STL》 ❌ 复习《设计模式》 ✅复习《Kotlin语言官方参考文档》 ✅学习《Swift编程权威指南》 ❌多媒体技术FFmpeg应用能力 ❌ 这里简述成果 OpenGL ES应用能力 ❌ 这里简述成果 Android平台多媒体接口应用 MediaCodec ❌ Camera ❌ Camera2 ❌ iOS平台多媒体接口应用 Audio Unit ❌ AVCapture ❌ ReplayKit ❌ AudioToolBox ❌ VideoToolBox ❌ libx264应用能力 ❌","link":"/2020%E5%B9%B4%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92.html"},{"title":"AVX2 优化 C++ 混响算法","text":"这里 是一份 C++ 混响算法的实现，修正掉索引下溢 BUG 后大概是这样： 123456789size_t samples = file.file_size / 4;size_t ir_samples = sizeof(ir) / 4;for (size_t i = 0; i &lt; samples; ++i){ for (size_t j = 0; j &lt; ir_samples &amp;&amp; i &gt;= j; ++j) { file.out_file_data[i] += file.in_file_data[i - j] * ir[j]; }} 在我的 Intel i7-7700 4 核机器上，混响一段 60s、单声道、float 采样的 pcm 音频需要 12452 ms 的时间。 内层循环是一个一维卷积，累加当前采样点之前所有采样点的混响（乘法）效果，展开后寻找规律： 1234567891011121314151617181920212223242526out[0] = in[0] * ir[0]out[1] = in[1] * ir[0] + in[0] * ir[1] out[2] = in[2] * ir[0] + in[1] * ir[1] + in[0] * ir[2] ......out[7] = in[7] * ir[0] + in[6] * ir[1] + in[5] * ir[2] + in[4] * ir[3] + in[3] * ir[4] + in[2] * ir[5] + in[1] * ir[6] + in[0] * ir[7]......out[n] = in[n] * ir[0] + in[n-1] * ir[1] + ... + in[0] * ir[n] AVX2 一次处理 8 个 float 数据，所以前 7 个采样的混响需要用 0 补齐，7 之后的采样就可以自后往前每次处理 8 个采样的混响和累加了；j 的步进也应该从 1 变成 8。 优化后，代码变成这个样子： 1234567891011121314151617181920212223242526272829303132333435363738394041size_t samples = file.file_size / 4;size_t ir_samples = sizeof(ir) / 4;for (size_t i = 0; i &lt; samples; ++i){ __m256 out = { 0 }; for (size_t j = 0; j &lt; ir_samples &amp;&amp; i &gt;= j; j += 8) { __m256 mm256_ir = _mm256_load_ps(ir + j); __m256 in; switch (i - j) { // _mm256_set_ps 以逆序加载数据，即第一个参数对应 out.m256_f32[7]，最后一个参数对应 out.m256_f32[0] case 0: in = _mm256_set_ps(0, 0, 0, 0, 0, 0, 0, file.in_file_data[0]); break; case 1: in = _mm256_set_ps(0, 0, 0, 0, 0, 0, file.in_file_data[0], file.in_file_data[1]); break; case 2: in = _mm256_set_ps(0, 0, 0, 0, 0, file.in_file_data[0], file.in_file_data[1], file.in_file_data[2]); break; case 3: in = _mm256_set_ps(0, 0, 0, 0, file.in_file_data[0], file.in_file_data[1], file.in_file_data[2], file.in_file_data[3]); break; case 4: in = _mm256_set_ps(0, 0, 0, file.in_file_data[0], file.in_file_data[1], file.in_file_data[2], file.in_file_data[3], file.in_file_data[4]); break; case 5: in = _mm256_set_ps(0, 0, file.in_file_data[0], file.in_file_data[1], file.in_file_data[2], file.in_file_data[3], file.in_file_data[4], file.in_file_data[5]); break; case 6: in = _mm256_set_ps(0, file.in_file_data[0], file.in_file_data[1], file.in_file_data[2], file.in_file_data[3], file.in_file_data[4], file.in_file_data[5], file.in_file_data[6]); break; default: in = _mm256_set_ps(file.in_file_data[i - j - 7], file.in_file_data[i - j - 6], file.in_file_data[i - j - 5], file.in_file_data[i - j - 4], file.in_file_data[i - j - 3], file.in_file_data[i - j - 2], file.in_file_data[i - j - 1], file.in_file_data[i - j]); break; } out = _mm256_fmadd_ps(in, mm256_ir, out); } file.out_file_data[i] = out.m256_f32[0] + out.m256_f32[1] + out.m256_f32[2] + out.m256_f32[3] + out.m256_f32[4] + out.m256_f32[5] + out.m256_f32[6] + out.m256_f32[7];} 耗时优化到了 1285 ms，性能提升了约 9.7 倍，超过了 AVX2 8 倍的理论时间上限，也可见编译器对 switch 分支优化的厉害程度。 完整测试项目在这里。","link":"/AVX2%E4%BC%98%E5%8C%96C++%E6%B7%B7%E5%93%8D%E7%AE%97%E6%B3%95.html"},{"title":"C++17 并行算法探究","text":"C++17 终于把并行计算引入到了 STL，且更新成本极低，只是把 大多数迭代算法函数 多加了一个并行版本的重载，实现了并行、并发两个维度上的性能优化。 比如，对一组数据做一个加倍的 transform： 串行版本，同以前：1std::transform(std::execution::seq, iter_begin, iter_end, output_iter, [](int val) { return val * 2; }); 并行版本，多以线程池方式实现： 1std::transform(std::execution::par, iter_begin, iter_end, output_iter, [](int val) { return val * 2; }); 并行 + 并发版本，同时以线程池和 SIMD 相关方法实现： 1std::transform(std::execution::par_unseq, iter_begin, iter_end, output_iter, [](int val) { return val * 2; }); 单独的并发版本 std::execution::unseq 已经加入到 C++20 标准。 但是，C++17 并行算法离可实际应用还差了十万八千里。 首先，编译器实现进度不理想。LLVM 彻底没展开此项工作 ；MSVC 仅完成部分算法的并行实现，即 std::execution::par_unseq 和 std::execution::par 完全等效，还是个半成品，常用的如 replace_copy_if 甚至并行版本都没实现；三去其二，GCC 即便完全支持，对跨平台开发的意义也不是很大了。 其次，如前所述，单独的并发版本是在 C++20 标准化的。个人认为这个才是杀器，应用面最广。并行要考虑线程切换、共享数据加锁等等负面因素，对一些小而频繁的数据加工，甚至有副作用。比如，直播音效的实现，为了保证低延时根本不允许缓存大块数据后再处理。并发的应用粒度小得多，对直播等场景不会造成负面影响。这大概也是编译器厂商不是那么热心的缘故之一吧…… 一句话总结，C++17 并行算法暂时没必要关注。","link":"/C++17%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95%E6%8E%A2%E7%A9%B6.html"},{"title":"FFmpeg 编码 H264 视频码率过高问题解决方法","text":"转码 mp4 的时候发现，输出的 H264 视频流码率高达 10M kbps+，而源码率只有约 2M kbps，这明显是不对的。明明已经通过 AVCodecContext::bit_rate 字段设定了码率却没有生效。 通过这篇 wiki，找到了答案。H264 有一套很复杂的码控规范，不能简单通过一个固定的码率数值指定输出码率——H264 基本上做不到这么精确的码控。推荐做法是启用 CRF 码控，设置合适的压缩率： 123456// 启用 CRF 码控// CRF 参数值取值范围为 [0,51]。0 为无损，51 最差；23 是 libx264 默认值。if (codec-&gt;id == AV_CODEC_ID_H264){ av_opt_set_int(_context, &quot;crf&quot;, 23, AV_OPT_SEARCH_CHILDREN);} 在 avcodec_open2() 之前加入上边代码块，输出视频流码率下降明显。","link":"/FFmpeg%E7%BC%96%E7%A0%81H264%E8%A7%86%E9%A2%91%E7%A0%81%E7%8E%87%E8%BF%87%E9%AB%98%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html"},{"title":"C++17 几个新的语言特性","text":"1. 结构化绑定声明绑定指定名称到初始化器的子对象或元素。 通俗地讲，对形如 std::pair、std::tuple 或自定义聚合类型的实例，可以声明一组变量直接指向其成员，无需创建一个对应聚合类型的临时变量： 1234std::pair&lt;int, int&gt; point{ 0, 1 };// some operations around point// ...auto [x, y] = point; // x equals to point.first; y equals to point.second 引用语法同样适用： 1234// keys to valuesstd::pair&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; kv;// ...auto&amp;&amp; [keys, values] = kv; 不过不能绑定到已声明变量上，还是要通过 std::tie() 绑定： 1234int x = 0, y = 0;std::pair&lt;int, int&gt; point{ 0, 1 };[x, y] = point; // 不支持这种语法std::tie(x, y) = point; // Ok 2. if &amp; switch 内初始化语句类似 for 循环的语法：if (init; condition)、switch (init; condition) 可以将 init 语句内声明的变量的生命周期限制在 if else、switch case 块内。优点显而易见，再也不用在外层作用域预先声明变量使其在 if else 内都可见了。极大程度上避免了名字污染问题。 1234if (const auto pos = myString.find(&quot;World&quot;); pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; &quot; World\\n&quot;;else std::cout &lt;&lt; pos &lt;&lt; &quot; not found!!\\n&quot;; 3. 类模版的模版参数推断模版参数类型推断终于普及到类模板了。在这之前，创建一个 std::pair 对象最常用的方法不是直接构造，而是通过 std::make_pair() 函数： 1auto myPair = std::make_pair(42, &quot;hello world&quot;); 为的就是利用函数模板的参数类型推断能力，可以少敲几下键盘。现在，类模版同样可以推断参数类型了： 12345// before: // std::pair&lt;int, const char*&gt; myPair{ 42, &quot;hello world&quot; }// now:std::pair myPair{ 42, &quot;hello world&quot; }; 对其它所有类模版同样适用： 12345// before:// std::array&lt;int, 3&gt; arr{ 1, 2, 3 };// now:std::array arr{ 1, 2, 3 }; 12345// before:// std::lock_guard&lt;std::mutex&gt; _(mtx);// now:// std::lock_guard _(mtx); 4. 折叠表达式展开一个参数包并对其中参数依次施以动作。算是对 C++11 里引入的变参模版的应用规则的一种优化吧。 折叠表达式支持 4 种形式的语法表达： ( pack op ... ) ( ... op pack ) ( pack op ... op init ) ( init op ... op pack ) 这里有详细的解释，比我在这胡说八道强多了。 一个经典的应用场景是日志打印： 12345678// 第四种语法的表现template &lt;class... Args&gt;void print(Args&amp;&amp;... args){ (cout &lt;&lt; ... &lt;&lt; std::forward&lt;Args&gt;(args)); // 注意：整个表达式以 () 包含。}print(1, 3, &quot;hello&quot;); // 打印出：13hello 输出的参数全挤在一起，这肯定不是想要的结果。可以改造下： 12345678// 第一种语法的表现template &lt;class... Args&gt;void print(Args&amp;&amp;... args){ ((cout &lt;&lt; std::forward&lt;Args&gt;(args) &lt;&lt; &quot; &quot;), ...);}print(1, 3, &quot;hello&quot;); // 打印出：1 3 hello 逗号左边两次输出以 () 包含，变成了一个表达式，等同于第一种语法的 pack 部分；‘,’ 即 op。整个表达式的意思就是对参数包内所有参数，先打印参数本身再打印一个空格符，依次操作。 参考资料：《C++17 in detail》 structured binding declaration fold expression","link":"/C++17%E5%87%A0%E4%B8%AA%E6%96%B0%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7.html"},{"title":"NEON 优化 C++ 混响算法","text":"普通的串行版本 和优化思路在这里。 跟 AVX2 不一样的大概是两点： NEON 指令只可以同时处理 4 个 float 数据 NEON 有自己的函数集 优化后的 NEON 版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243size_t samples = file.file_size / 4;size_t ir_samples = sizeof(ir) / 4;for (size_t i = 0; i &lt; samples; ++i){ float32x4_t out = { 0 }; for (size_t j = 0; j &lt; ir_samples &amp;&amp; i &gt;= j; j += 4) { float32x4_t ir_x4 = vld1q_f32(ir + j); float32x4_t in; switch (i - j) { case 0: { float temp[4] = {file.in_file_data[0], 0, 0, 0}; in = vld1q_f32(temp); break; } case 1: { float temp[4] = {file.in_file_data[1], file.in_file_data[0], 0, 0}; in = vld1q_f32(temp); break; } case 2: { float temp[4] = {file.in_file_data[2], file.in_file_data[1], file.in_file_data[0], 0}; in = vld1q_f32(temp); break; } default: // float temp[4] = {file.in_file_data[i-j], file.in_file_data[i-j-1], file.in_file_data[i-j-2], file.in_file_data[i-j-3]}; // in = vld1q_f32(temp); in = vld1q_f32(file.in_file_data + i - j - 3); in = vrev64q_f32(in); break; } out = vmlaq_f32(out, in, ir_x4); } file.out_file_data[i] += vgetq_lane_f32(out, 0); file.out_file_data[i] += vgetq_lane_f32(out, 1); file.out_file_data[i] += vgetq_lane_f32(out, 2); file.out_file_data[i] += vgetq_lane_f32(out, 3);} NEON 函数集跟 AVX2 略有不同，只有顺序加载的 load ( vld1q_f32() )，没有逆序、离散加载的 set，所以需要构造一个临时的 float 数组，逆序赋值，再传入 load 函数。 不需要补零时，构造临时 float 数组再 load，效率明显低于上边代码示例里 default 块的实现方式，即先一次性 load 4个数据后再反转。在我的测试用例里，单这一个改动就提升了约 10% 的性能。 完整的 Android 测试工程在这里","link":"/NEON%E4%BC%98%E5%8C%96C++%E6%B7%B7%E5%93%8D%E7%AE%97%E6%B3%95.html"},{"title":"Python3 爬虫初体验","text":"数据提取通过 PyCharm 的包管理工具分别下载安装 requests 、bs4 、lxml 库。 requests 库requests 是一个简洁优雅的 HTTP 库，基于 urllib3 再封装。一个 get 请求用一行代码即可实现： 1res = requests.get('https://github.com/') 许多网站会根据 Request Header 识别请求是否来自非爬虫应用，可以通过伪造 Header 骗过，比如，把自己伪装成一个 Chrome 浏览器： 1234headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36'}res = requests.get('https://github.com/', headers=headers) 可以通过浏览器的开发者工具获取到完整的头信息列表，做到完美伪装。 BeautifulSoup 和 lxml 库bs4 即 BeautifulSoup ，是一个可以从 HTML 或 XML 文件中提取数据的库。它支持以多种形式遍历、查找 HTML 内容，比如 CSS 的选择器、标签类型甚至正则表达式。BeautifulSoup 可以配合第三方 HTML 解析器使用，比如 lxml 。lxml 运行效率比标准库高，大概算是事实标准库了吧。 基于上述准备工作，即可完成大部分的静态页面内容抓取，比如，获取 GitHub 首页的 body 内容： 123456import requestsfrom bs4 import BeautifulSouprsp = requests.get('https://github.com/')soup = BeautifulSoup(rsp.text, 'lxml')print(soup.find('body')) # 打印出网页 body 内容 配合浏览器的开发者工具，可以拿到网页所有标签的 css selector，据此可以提取出更精细的数据，比如，拿到 GitHub 用户的头像： 12345rsp = requests.get('https://github.com/liangzuoting')soup = BeautifulSoup(rsp.text, 'lxml')img = soup.select('#js-pjax-container &gt; div.container-xl.px-3.px-md-4.px-lg-5 &gt; div &gt; div.flex-shrink-0.col-12.col-md-3.mb-4.mb-md-0 &gt; div &gt; div.clearfix.d-flex.d-md-block.flex-items-center.mb-4.mb-md-0 &gt; div.position-relative.d-inline-block.col-2.col-md-12.mr-3.mr-md-0.flex-shrink-0 &gt; a &gt; img')if len(img) &gt; 0: print(img[0].get('src')) # 打印出头像图片 url BeautifulSoup.select 函数接受一个 css selector 字符串，并返回匹配列表。 数据存储通过 Python 内置的 csv 库，可以很方便的将提取的数据写入到 csv 文件。 1234567import csvf = open('d:\\dd.csv', mode='w', newline='\\n', encoding='utf-8-sig')w = csv.writer(f)w.writerow(['1', '二,三,四', '5\\n6\\n7'])w.writerow(['11', '22,33,44', '55\\n66\\n77'])f.close() 务必显式指定 newline 参数为 \\n，Windows 平台下默认用 \\r\\n 做换行符，在 excel 里打开 csv 文件后出现空白行。 以 utf-8-sig 编码创建文件，能解决非 ascii 码字符乱码问题，sig 即 BOM，显式地把字节序写入到了文件里。 以换行符插入项字符串内，可实现单元格内换行。对以列表存储的动态数据，需要定义自己的字符串格式化函数： 12def ls_to_str(ls): '\\n'.join(map(str, ls)) map 函数把 ls 列表项通过 str 函数依次映射成字符串，这个在列表项是自定义类型时是必须的，否则列表项只记录其地址值。 小结爬虫入门还是很简单的，Python 完整的生态链功不可没。问题总是出在意想不到的地方，比如 Chrome 的弹窗自动拦截。通过开发者工具获取到的 selector 是拦截后页面的层级关系，导致 BeautifulSoup.select 获取的数据总是对不上。可以关闭浏览器的相关功能；或从 requests 导出完整的页面内容，保存成 HTML 文件后再解析。","link":"/Python%E7%88%AC%E8%99%AB%E5%88%9D%E4%BD%93%E9%AA%8C.html"},{"title":"StreamingCore 项目介绍","text":"是时候驻足整装了明年的业余时间会集中在这个StreamingCore项目上。进入直播行业也有六七年时间了，这将是我迄今的职业生涯中最重要的一份总结。 如同其名，StreamingCore将是一套直播核心流程的解决方案，集成采集、编码、推流功能，同时支持Android和iOS两端。借鉴FFmpeg的设计思想，StreamingCore也会以模块化架构实现，允许独立使用某一功能模块。同一功能模块，或许会提供多套实现方案，以供比较选择。 暂拟定的功能模块音频采集模块 OpenSL ES implementation for Android AudioRecord implementation for Android Audio Unit implementation for iOS 图像采集模块 Implementation based on Camera interface for Android Implementation based on Camera2 interface for Android Implementation based on Virtual Display for Android Implementation based on AVFoundation framework for iOS Implementation based on ReplayKit for iOS 音频编码模块 Audio Encoder implementation based on MediaCodec for Android Audio Encoder implementation based on AudioToolBox for iOS 视频编码模块 Video Encoder implementation based on MediaCodec for Android Video Encoder implementation based on VideoToolBox for iOS 推流模块 Streaming by Rtmp Protocol Streaming by custom Protocol based on UDP 各个模块将暴露标准化接口，供扩展实现。 我不喜欢Java和Objective-C或者反过来说，我喜欢Kotlin和Swift。够简洁，够现代化，这就足够了。公司业务已呈现尾大不掉、积重难返之态，更加之KPI当头，相关负责人没有勇气切换到新的开发环境。我已学的Kotlin，我想学的Swift，几无用武之地，这也是我萌生实施此项目的一个重要原因。 同样基于这个技术决定，项目质量无从保证。成品后能否被接入方接受，就更难说了…… 大概的开发计划 时间周期为一年（2020.1.1——2020.12.31） 先Android端全功能，再iOS端","link":"/StreamingCore%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D.html"},{"title":"使用 Unity 开发 Android VR 应用系列之一——开发环境设置","text":"0. 读者定位 熟悉 Android 开发 对 C#/.NET 有一定了解 想学习如何通过 Unity 开发 Android 应用 Unity 是微软旗下的跨平台游戏/应用开发工具，C# 自然成为其首推支持的前端开发语言。C# 虽是从 Java 脱胎而出，经过近二十年的独立发展，已经成长为一门明显优于 Java 的现代化语言（这当然是我个人的主观见解）。我也发愿以此项目为起点，重新掌握 C#/.NET 的技术体系。 1. 开发环境一览 Windwos 10, 16 GB RAM, 1060 3GB+ 独显 Unity 对硬件具有一定要求，不仅指构建版本，开发过程中还需要频繁使用开发机运行调试项目，硬件配置对开发效率的影响还是比较大的。 Android Studio 环境（包括 SDK 和 NDK） 不确定 Unity 兼容所有 Android Studio 版本环境——毕竟 Android Studio 本身就存在比较显著的版本兼容性问题。所以如果你碰到项目配置相关的错误，建议尝试提高或降低 Android Studio/SDK/NDK 版本来解决。我个人的 Android Studio 环境是 Android Studio 3.5.3/SDK Platform 26/NDK r16b。 Unity 2018.4.14f1 Unity 存在多个并行版本，包括 2017/2018/2019 等系列。大版本间互不兼容，所以立项之初 Unity 版本选择是一个重要任务。版本选择大概有几个原则： 依赖方的要求，很多第三方 SDK 不保证兼容所有 Unity 版本 优先使用 LTS (Long Term Support) 版本，LTS 意味着官方的持续维护，版本质量更高 如果想体验所有新功能，优选 2019 版本；如果更注重产品的稳定性，优选 2018 版本。LTS 并不意味着会同步所有最新版本的大功能，所以 2018 LTS 的功能是弱于 2019 系列的 Visual Studio Community 2019 此项可选。通过一些渠道安装 Unity，会同时包含 Visual Studio Community 2017 的安装选项，这已经足够了。 Pico G2 4K 眼镜 我们应用的适配机型之一，我个人的最爱 2. 首次运行设置1) Unity 关联 Android 环境 启动 Unity，依次选中菜单项 Edit - Preferences - External Tools，显示如下: 按实际安装路径分别填充标注的两个选项。没有用到 NDK 时，此项可空。 2) Android App 构建配置 在 Unity 中依次选中菜单项 Edit - Project Settings，在弹出窗口中的左栏选中 Player 选项后，在右栏切换到 Android settings 标签页。 选项繁多，不一一介绍。强烈建议对照文档熟练掌握所有选项含义，这是十分有意义的。这里仅介绍几个”高级”选项。 2.1) 自定义 Gradle 脚本 选中 Publishing Settings 下拉菜单，勾选如上图标识选项。Unity 默认使用对用户隐藏的 gradle 脚本构建 App，使用自定义 gradle 脚本，给开发者提供了从更细粒度上干预构建过程的能力。 2.2) C# 脚本配置 在 Other Settings 下拉菜单中，按上图所示设置各选项。将 .NET 运行时版本提升到 4.x 的原因是可以使用 C# 6.0 特性。 3) Unity 关联 Visual Studio Preferences 窗口中的 External Tools 标签页中，有如下选项 如果你的 Visual Studio 是通过 Unity 安装器打包安装，这里已经自动关联；如果想手动切换到其它 Visual Studio 实例，可以通过点击这里，浏览本地安装目录，找到并选中 devenv.exe 即可。如果这里没有配置正确，在 Visual Studio 中打开脚本文件后将不能成功自动感知，且不能通过 “附加到 Unity” 功能实时调试脚本。虽然不影响脚本的正常编译，对开发效率无疑是巨大打击。 3. 后记文中所记并非一个完整的 “Unity 下开发 Android App 配置流程”，此种教程文档网络上已数不胜数，我也是参照此类文章迈出的第一步。此文的价值，恰恰在于它是对此类千篇一律的入门流水账的一个重要补充，是我开发过程中一些痛苦教训的精炼提取，可以让你的第一步迈得更扎实。叙事的同时，也掺杂了很多我个人的理解。限于认知，如有冒犯或错误或词不达意等负面情绪传递，凡此种种，请留言指正，谢谢。","link":"/Unity%E5%BC%80%E5%8F%91Android-VR%E5%BA%94%E7%94%A8%E4%B8%80%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE.html"},{"title":"在 Unity 项目中使用 OpenFileDialog 实现选择文件功能","text":"开发阶段用的是 UnityEditor.EditorUtility.OpenFilePanel() 函数，简单易用。但是如其名所示，UnityEditor 只在 Unity 编辑器内可见，尝试 build 出 Windows 下 standalone 包时会报编译错误。 解决办法是用 mono 库下的相应功能实现打开文件。 在 Unity 安装根目录的 \\Editor\\Data\\Mono\\lib\\mono\\2.0\\ 路径下找到并复制 System.Windows.Forms.dll 粘贴 dll 文件到 Unity 项目的 Assets\\Plugins\\ 目录 PlayerSettings 中 Api Compatibility Level 选项值从默认的 .NET Standard 2.0 调整为 .NET 4.x 此时，dll 在 Unity 项目中变为可见，可以在脚本文件中使用 dll 中任意功能了。 选择文件对话框通过 System.Windows.Forms.OpenFileDialog 类实现，一个典型用法如下： 12345678System.Windows.Forms.OpenFileDialog ofd = new System.Windows.Forms.OpenFileDialog();ofd.Filter = &quot;Video Files(*.mp4;*.flv)|*.mp4;*.flv&quot;;ofd.RestoreDirectory = true;if (ofd.ShowDialog() != System.Windows.Forms.DialogResult.OK){ return; // user clicked cancel.}var filePath = ofd.FileName; //filePath holds the file's full path. 具体用例参考我的 XOPlayer项目 issues: mono 实现的 OpenFileDialog 太丑了……是非基于宿主系统原生实现的。我用的 Unity 2018.4.14f1 提供的是 mono 2.0 版本，不知是否跟 mono 版本过旧有关。","link":"/Unity%E4%B8%AD%E7%94%A8OpenFileDialog%E5%AE%9E%E7%8E%B0%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD.html"},{"title":"使用 Unity 开发 Android VR 应用系列之三——实现场景管理器","text":"0. 需求分析绝大多数应用里，都会有类似的业务逻辑：从 A 页面跳转到 B 页面，执行一系列操作后返回 A 页面。 这看似寻常的操作流程，Unity 是不能天然支持的。Unity 的 SceneManager 和 Android 的 activity stacks 在”页面”管理策略上大概有以下不同： 加载 B 场景，默认会销毁 A 场景 这种情况下想实现返回功能，必须重新加载 A，并且还原 A 销毁前的所有状态（滚动条位置等等）——业务逻辑越复杂，要记住的状态越多，这个方案不具有普适性。可显式指定以 Additive 模式加载新场景，加载 B 后仍将 A 保留。但是： Additive 模式加载 B 后，A 不会被隐藏 绝大多数情况下，这也不是我们期望的行为。所以需要基于 Additive 逻辑更进一步，使 B 加载后 A 自动隐藏。 综上，SceneManager 并不满足常见需求，需要自己实现一个 “scene stack”，使多个场景形成 LIFO 的栈式结构。 1. 系统设计以一组类图表示各参与者及其关系： SceneStack 以链表保存场景上下文信息，负责场景的加载与销毁。 注意 SetFirstScene(string sceneName, ControllerBase controller) 函数。应用中第一个场景是由系统负责加载的，用户没有干预的余地，所以只能在其加载后通过此函数手工添加到栈里。 ControllerBase Controller 即是最上层 UI 元素（通常是一个 Canvas）关联的脚本（MonoBehaviour）组件。将 controller 同对应的场景同时保存到 SceneStack 中，即可通过 controller 函数控制场景的显示与隐藏。 如此，基本实现了”新场景加载时使旧场景隐藏而不销毁”的流程化、自动化。 2. 代码实现完整的代码实现在这里，同时提供一个两个场景的简单测试用例。 3. 总结其实，我一直在混用”场景”与 “UI” 的概念。以 MVC 模型解构 Unity 的 UI 系统，场景是 Controller，UI 是 View。所以准确地说，我上述所提到的显示/隐藏，目标不是场景，而是场景内的 UI 元素。 实际也确实如此，Scene 类是没有类似显示/隐藏的接口可用的，代码里操作的是场景内 UI 根元素。我之所以如此表述，只是单纯地想简化描述罢了——毕竟隐藏了所有 UI，就好像是场景隐藏了一样。","link":"/Unity%E5%BC%80%E5%8F%91Android-VR%E5%BA%94%E7%94%A8%E4%B8%89%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%9C%BA%E6%99%AF%E7%AE%A1%E7%90%86%E5%99%A8.html"},{"title":"使用 Unity 开发 Android VR 应用系列之二——使用 Animator 实现鼠标悬浮 UI 缩放动画效果","text":"0. 概览展示效果如下 完整的代码和示例在这里 实现上图所示的动画效果，涉及两个 Unity 知识点： Animator 组件 动态调整 UI 渲染顺序 1. 使用 Animator 实现缩放动画Animator 是一套灵活度跟复杂度同样高的动画系统。简单来讲，其运作原理是：定义若干 Animation Clip，将其在 Animator Controller 中通过 Transition 拼装成一个状态机；创建若干 Parameters，用户通过为其赋不同值控制状态转移。 套用到本例来说，就是： 创建两个 Animation Clip，一个用于放大，一个用于缩小 创建一个 Animator Controller，在其中创建两个状态，分别对应上边两个 Animation Clip 创建一个 bool 参数 hovering，射线进入时为 true，射线移开时为 false 创建两个 Transition，分别使 hovering = true 时执行放大动画，hovering = false 时执行缩小动画 最终，Animator Controller 中呈现如下的状态图： 2. 使用 Canvas 组件实现动态调整渲染顺序默认的 UI 渲染顺序是按其在场景中出现的先后顺序定义的。带来的一个问题是：当对靠前的 UI 做放大动画时，有可能和后面的 UI 重叠，导致当前选中 UI 被遮挡。 可以通过为 UI 添加 Canvas 组件解决此问题。 注意图中的 Graphic Raycaster 组件，需要同 Canvas 成对出现，否则 UI 不能正常处理射线事件。 内嵌的 Canvas 具有上图所示的属性。勾选 Override Sorting 后，通过修改 Order in Layer 项值即可自定义当前 UI 的渲染顺序，值越大，渲染顺序越靠后。 脚本代码如下： 123456789101112// 添加 Canvas 和 GraphicRaycaster 组件if (topWhenHover) // 仅在需要时动态添加相应组件{ if (GetComponent&lt;Canvas&gt;() == null) { gameObject.AddComponent&lt;Canvas&gt;(); } if (GetComponent&lt;GraphicRaycaster&gt;() == null) { gameObject.AddComponent&lt;GraphicRaycaster&gt;(); }} 1234567891011// hover 状态变化时private void OnHoverChanged(bool hover){ if (topWhenHover) { var canvas = GetComponent&lt;Canvas&gt;(); canvas.overrideSorting = hover; canvas.sortingOrder = sortingOrder; } ...} 3. 把所有功能封装到一个自定义组件中可以实现一个高度封装的组件：用户只需要添加此组件，即可自动监听射线进出事件并执行动画。 1. 使组件能接收射线进出事件12345678910111213// 实现对应接口public class HoverScaler : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler{ public void OnPointerEnter(PointerEventData eventData) { OnHoverChanged(true); } public void OnPointerExit(PointerEventData eventData) { OnHoverChanged(false); }} 2. 添加 Animator 组件到 UI123456void Start() { animator = gameObject.AddComponent&lt;Animator&gt;(); var controller = Resources.Load&lt;RuntimeAnimatorController&gt;(&quot;Animations/ScaleWhenHover&quot;); animator.runtimeAnimatorController = Instantiate(controller); } 完整的组件实现在这里 4. Issues 修改 Canvas 的 sortingOrder 属性，会使其父 UI 的 mask 功能失效（demo 有演示）","link":"/Unity%E5%BC%80%E5%8F%91Android-VR%E5%BA%94%E7%94%A8%E4%BA%8C%E2%80%94%E2%80%94Animator%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%82%AC%E6%B5%AEUI%E7%BC%A9%E6%94%BE%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C.html"},{"title":"使用 Unity 开发 Android VR 应用系列之四——用 ScriptableObject 实现预加载","text":"ScriptableObject 是一个数据容器类，可以用它来存储与类实例无关的数据。ScriptableObject 一个主要用途是利用它存储共享资源（比如 Prefab），减少无谓的复制，降低内存使用。 比如说，场景 A 和场景 B 都需要一个登录对话框。常规做法是创建一个 Prefab，分别在 A 和 B 中各自实例化；为了节省内存，可以在 ScriptableObject 中实例此 Prefab，在运行时将此 Prefab 实例添加到 A/B 场景中。 ScriptableObject 最典型的一个应用场景，便是用它来实现预加载了。 如上图，在 Player Settings 的 Optimization 分类下有一个 Preloaded Assets 数组选项。数组列出的 .asset 类型的资源会在程序启动时加载，并一直存活到程序退出。 .asset 资源对应的就是 ScriptableObject。实现 ScriptableObject 类时，需使用 CreateAssetMenu 属性为此 ScriptableObject 在 Assets 菜单中创建一个使用入口： 123456789101112131415// 模仿 lua，创建一个名字为 G 的类，意指此类为 Global used.[CreateAssetMenu(fileName = &quot;GlobalAsset&quot;, menuName = &quot;GlobalAsset&quot;)]public class G : ScriptableObject{// 实例被加载后会触发此回调private void OnEnable(){// 缓存材质资源...// 预先创建对象池...}} 上边的示例代码在 Assets-Create 菜单栏下创建了一个 GlobalAsset 菜单项，通过此菜单项便可方便地创建一个 GlobalAsset.asset 的资源文件。将此资源文件添加到预加载数组中后，程序启动时就会自动实例化一个 G 类实例，实例在被加载后会触发 OnEnable 消息，可以在此回调中实现具体的预加载逻辑。 简言之，ScriptableObject 是 Unity 提供的可完美取代 Singleton 的内建数据共享机制。","link":"/Unity%E5%BC%80%E5%8F%91Android-VR%E5%BA%94%E7%94%A8%E5%9B%9B%E2%80%94%E2%80%94ScriptableObject%E5%AE%9E%E7%8E%B0%E9%A2%84%E5%8A%A0%E8%BD%BD.html"},{"title":"VS2019 编译 QtPropertyBrowser 源码","text":"尝试在 VS 2019 中导入 QtPropertyBrowser 源码到 VS 工程（vcxproj）进行编译时，遇到如下编译错误： 12345671&gt;moc_qtpropertybrowser.cpp1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\x64\\Debug\\moc\\moc_qtbuttonpropertybrowser.cpp(94,29): error C2027: 使用了未定义类型“QtButtonPropertyBrowserPrivate”1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\qtpropertybrowser\\qtbuttonpropertybrowser.h(47): message : 参见“QtButtonPropertyBrowserPrivate”的声明1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\x64\\Debug\\moc\\moc_qtbuttonpropertybrowser.cpp(95,29): error C2027: 使用了未定义类型“QtButtonPropertyBrowserPrivate”1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\qtpropertybrowser\\qtbuttonpropertybrowser.h(47): message : 参见“QtButtonPropertyBrowserPrivate”的声明1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\x64\\Debug\\moc\\moc_qtbuttonpropertybrowser.cpp(96,29): error C2027: 使用了未定义类型“QtButtonPropertyBrowserPrivate”1&gt;E:\\QtPropertyBrowserDemo\\QtPropertyBrowserDemo\\qtpropertybrowser\\qtbuttonpropertybrowser.h(47): message : 参见“QtButtonPropertyBrowserPrivate”的声明 解决办法如下： 在 VS 项目目录内右键对应 moc 文件的头文件，选中属性—Qt Meta-Object Compiler—moc，将 C++ Dynamic Source 值从 “Output File” 改为 “Disable”，重新编译即可。 简言之，这个项的作用是将当前文件中 Qt 类生成的 moc 源文件在编译阶段动态添加到编译器的源码文件列表中。 因为 Private 类的定义在 x.cpp 文件而非 x.h 中，导致编译 moc_x.cpp 时找不到类定义。 项值 Disable 即不将 moc_x.cpp 动态添加到编译器中。这么做是没问题的，因为 QtPropertyBrowser 相关源文件的最后都已显式 include 了对应的 moc.cpp。 具体可参考： https://forum.qt.io/topic/119401/how-to-compile-source-code-of-qtpropertybrowser-by-vs2019-correctly https://www.qt.io/blog/2018/01/24/qt-visual-studio-new-approach-based-msbuild","link":"/VS2019%E7%BC%96%E8%AF%91QtPropertyBrowser%E6%BA%90%E7%A0%81.html"},{"title":"XOPlayer 阶段性总结——使用 Unity 的 VideoPlayer 组件开发全景播放器","text":"项目地址 现在还只是一个简陋的单 Scene 的应用，但已具备基本的视频播放和播放控制能力： 本地视频播放 进度显示、跳转 暂停、恢复、停止 音量调节 视频源类型切换 播放界面如下： 0. 开发、运行环境 VS2019 Community。安装时务必勾选 Visual Studio Tools for Unity。 Unity 2018.4.14f1。运行时修改菜单 Edit-Preferences 的 External Tools 选项页中的 External Script Editor 项值，关联到 VS2019，方能在 VS2019 中正确识别 Unity 工程和源码。 AMD Ryzen7 1700 + GTX 1070 + DDR4 16GB 1. UI 布局一览 模块化的组合功能均以 Prefab 实现（蓝色组件）。Prefab 既提供了一种可复用手段（2次出现的 Slider 以同一 Prefab 实例化），又契合了高内聚，低耦合的设计理念。我的理解是：相比于直接在 Scene 中布局复杂界面，Prefab 是更优选择，能用则用。 注意 VideoPlayer 所在位置，出现在根 Canvas 之外，原因参考 2. VideoPlayer。 2. VideoPlayer 相关以流媒体角度解读 VideoPlayer 的话，VideoPlayer 是一个 demuxers，decoders 和 renders 的组合。注意这里说的渲染，非指渲染到 UI，而是以某种标准格式渲染到内存或显存，从内存/显存渲染到 UI 是用户职责。所以，VideoPlayer 被设计为非 UI 组件，这也是上文提到 VideoPlayer 为什么出现在根 Canvas 之外的原因。 VideoPlayer 提供了多种 Render Mode，适配不同的渲染场景，XOPlayer 只用到了 Render Texture 一种。此纹理须在脚本中动态创建并关联到 VideoPlayer ： 12345678910// make sure: mPlayer.prepareCompleted += onPrepareCompleted.// width &amp; height are available until prepared.private void onPrepareCompleted(VideoPlayer videoPlayer){ mVideoTexture = new RenderTexture((int)mPlayer.width, (int)mPlayer.height, 0, RenderTextureFormat.ARGB32); mPlayer.targetTexture = mVideoTexture; // attaching texture to material // attaching material to some kind of UI controls, e.g., Image, global Skybox. mPlayer.Play();} XOPlayer 支持普通视频和全景视频的播放，两者在渲染到 UI 时大不相同： 普通视频渲染到 Image 组件 全景视频渲染到全局 Skybox 或 Sphere 此逻辑应补充在 RenderTexture 创建后、视频播放前： 123456789101112// attaching texture to material// attaching material to some kind of UI controls, e.g., Image, global Skybox.if (mMode == PlayMode.kNormal) // normal videos{ video2DMaterial.mainTexture = mVideoTexture; normalPlayer.GetComponent&lt;Image&gt;().material = video2DMaterial;}else // panoramic videos{ videoPanoramicMaterial.mainTexture = mVideoTexture; RenderSettings.skybox = videoPanoramicMaterial;} video2DMaterial 是一个预先定义的材质，Shader 采用 “Unlit/Texture” videoPanoramicMaterial 是一个预先定义的材质，Shader 采用 “Skybox/Panoramic” 全景视频的视角又分为 180° 和 360°，可以通过预先定义 2 个不同的材质，Image Type 分别设置为 180 Degrees 和 360 Degrees 实现；也可以只创建一个材质，脚本中动态切换 Image Type : 123456789if (mMode == PlayMode.kPanoramic180) // 180 degrees panoramic videos{ videoPanoramicMaterial.SetFloat(&quot;_ImageType&quot;, 1f); }else // 360 degrees panoramic videos{ videoPanoramicMaterial.SetFloat(&quot;_ImageType&quot;, 0f);} 3. 其它3.1 全景视频的视角旋转 PC 上通过鼠标拖拽驱动视角旋转。天空盒内，只需要将 Main Camera 按其自身 position 沿 X/Y 轴旋转即可： 123456789101112private float rotateSpeed = 2.0f;// commonly, we track Input status in Update loop.void Update(){ if (Input.GetMouseButton(0)) // if left mouse button pressed down { // rotate about x asix transform.RotateAround(transform.position, Vector3.down, rotateSpeed * Input.GetAxis(&quot;Mouse X&quot;)); // rotate about y asix transform.RotateAround(transform.position, transform.right, rotateSpeed * Input.GetAxis(&quot;Mouse Y&quot;)); }} 3.2 鼠标点击任意处显示/隐藏工具栏 因为绝大部分逻辑均在 VideoPlayer 组件的脚本 PlayerManager 内实现，所以第一反应是通过 PlayerManager 实现 IPointerDownHandler, IPointerUpHandler 接口即可。 结论是不可以。上文已经提及，VideoPlayer 不是 UI 组件，没有 Rect Transform，所以它其实是不可能接受鼠标事件的。 所以需要在根 Canvas 上添加脚本，并实现 IPointerDownHandler, IPointerUpHandler ： 1234567891011121314public class PointerHandler : MonoBehaviour, IPointerDownHandler, IPointerUpHandler{ // attaching to PlayerManager script. public PlayerManager playerManager; public void OnPointerDown(PointerEventData eventData) { } public void OnPointerUp(PointerEventData eventData) { playerManager.OnPointerUp(); // we do actions in PlayerManager. }} 3.3 普通视频播放相关 普通视频的调用链是这样的： VideoPlayer——RenderTexture——video2DMaterial——normalPlayer 其中 RenderTexture 是动态创建的，直接导致 normalPlayer.GetComponent&lt;Image&gt;().material 属性不能通过 Inspector 面板关联（指 video2DMaterial——normalPlayer），甚至在 Start() 中赋值也不行。Image 画面不会随播放更新。没有找到相关资料支持，但是我反推的结论是： 123mVideoTexture = new RenderTexture((int)mPlayer.width, (int)mPlayer.height, 0, RenderTextureFormat.ARGB32);video2DMaterial.mainTexture = mVideoTexture;normalPlayer.GetComponent&lt;Image&gt;().material = video2DMaterial; 这三句的调用顺序是不能变动的。即需要先完备材质信息，才能将材质赋值给 Image (或其它 UI 组件 ?)。 停止播放时存在类似问题： 123mPlayer.Stop();// 这句赋空是必须的，否则 Image 变为不可重入，再播放视频时画面不能更新。normalPlayer.GetComponent&lt;Image&gt;().material = null; 结合创建时的三句代码反推，结论是：再次播放时 VideoTexture 是重新创建的，但是 video2DMaterial 不是，所以 normalPlayer 跟踪不到这个间接变化。 得出一个不知道对错的结论：一个调用链上的对象，最好要么全部静态创建，要么全部动态创建。4. Issues 基本功能缺失：快进、快退、循环 180° 全景视频的旋转角度是 360° 进度条 Slider 不能拖动（OnValueChanged 死循环） 全景视频变糊（存疑）","link":"/xoplayer%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93.html"},{"title":"基于 FFmpeg 的视频编辑器开发—踩坑记","text":"折腾了两周，视频编辑器已初具规模： 解封装 解码 快速跳转和精准跳转 格式转换 缩放 重采样 添加文字 添加 srt 字幕 编码 封装 基本满足了当初想做一个 gif 生成器的需求，也是时候回顾下过去两周踩过的坑了。 1. av_seek_frame() 后解码，第一帧的 pts 仍为 seek 前的 ptsav_seek_frame() 是 avformat 模块接口，seek 后信息没有同步到 avcodec 模块。 seek 后马上调用 avcodec_flush_buffers() 即可。 2. 解码后视频帧 pts 为 AV_NOPTS_VALUEAV_NOPTS_VALUE 是一个极大的负数值的宏定义。pts 字段值是它时，说明此视频格式不支持或此视频未设置 pts。应把 pts 值设为同 pkt_dts 值： 1234// frame is a decoded AVFrameif (frame-&gt;pts == AV_NOPTS_VALUE) { frame-&gt;pts = frame-&gt;pkt_dts;} 3. av_read_frame() 后 调用 av_packet_unref() 释放 AVPacket 对象av_read_frame() 会将传入的 AVPacket 对象变为引用计数形态，或在传入 AVPacket 对象已经是引用计数形态时将计数 + 1，应用层负责在合适时机调用 av_packet_unref 将计数 - 1。否则 AVPacket 对象内缓存区将永远不会释放，导致内存泄漏。 4. 将滤镜图输出到文本文件进行调试分析这其实是个官方提供的命令行工具来的，叫 graph2dot 。只需将其中 print_digraph() 函数定义复制到自己的工程内，即可打印出如下图所示的滤镜图内的关系链： 结合 print_digraph() 源码和生成的文本描述，对 filter graph 的内部逻辑也能略窥一二。 5. 使音频滤镜吐出固定尺寸（采样数）许多音频编码器如 AAC，要求传递给 avcodec_send_frame() 的 AVFrame 对象包含固定尺寸（采样数）的音频数据，否则返回值将会是 AVERROR(EINVAL)。没必要自己缓存音频数据至指定尺寸再发送给编码器，可以直接调用 av_buffersink_set_frame_size() 接口，指示 sink 滤镜总是吐出指定尺寸的帧数据。 1234// 在 avfilter_graph_config() 后调用一次即可if (!(audioCodecContext-&gt;codec-&gt;capabilities &amp; AV_CODEC_CAP_VARIABLE_FRAME_SIZE)) { av_buffersink_set_frame_size(sinkContext, audioCodecContext-&gt;frame_size);} 6. 封装时应重新计算 pts编码时，应以写入的实际帧率/采样率设置编码器的 time_base 字段，同时将输入帧的 pts 从零计算： 123456789101112// for video encodervideoCodecContext-&gt;time_base = { 1, fps };// ...// int vPts = 0;videoFrame-&gt;pts = vPts++;// for audio encoderaudioCodecContext-&gt;time_base = { 1, sampleRate };// ...// int aPts = 0;audioFrame-&gt;pts = aPts;aPts += audioFrame-&gt;nb_samples; 最后，在编码后写入前，应将 AVPacket 时间戳转换为相应流的 time_base 单位： 1av_packet_rescale_ts(&amp;packet, codecContext-&gt;time_base, stream-&gt;time_base); 7. 解封装到文件尾（EOF）时，末尾若干帧丢失av_read_frame() 返回 AVERROR_EOF 时，不应该直接结束后续操作。编解码器、滤镜均不是一进一出，所以很有可能在 av_read_frame() 返回 AVERROR_EOF 时，编解码器、滤镜中仍存在待处理的帧数据。 对解码器，以一个空 AVPacket 指针传入 avcodec_send_packet() 可以起到 flush 对应解码器的作用； 同理，对编码器应以一个空 AVFrame 指针为参数调用 avcodec_send_frame()； 滤镜的 flush 有两种方式： 以空 AVFrame 指针调用 av_buffersrc_add_frame_flags() 不需要调用 av_buffersrc_add_frame() 或 av_buffersrc_add_frame_flags()，直接以 AV_BUFFERSINK_FLAG_NO_REQUEST 参数调用 av_buffersink_get_frame_flags()","link":"/%E5%9F%BA%E4%BA%8EFFmpeg%E7%9A%84%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E2%80%94%E8%B8%A9%E5%9D%91%E8%AE%B0.html"},{"title":"用 FFmpeg 制作 GIF","text":"ffmpeg -y -ss 1:33:28 -t 22 -i input.mp4 -vf &quot;scale=iw*0.3:ih*0.3,drawtext=x=(w-text_w)/2:y=h-40:fontsize=30:fontcolor=white:fontfile=C\\\\:/Windows/Fonts/STXINWEI.TTF:text='这是文字'&quot; -r 15 output.gif 从 input.mp4 的 1:33:28 处开始截取 22 秒；输出尺寸缩小到输入的 0.3 倍；在输出图的中下部分添加文字，文字样式为白色、30像素、新魏；把输出 gif 图的帧率设为 15。 note: 1) 多个 filter 效果以,拼接，且以出现的先后顺序逐个应用到输出上。所以，drawtext 里用到的w、h是缩放后的尺寸；2) 注意fontfile值的表现方式。","link":"/%E7%94%A8FFmpeg%E5%88%B6%E4%BD%9CGIF.html"},{"title":"用 FFmpeg 下载视频","text":"ffmpeg -i &quot;https://us.sinaimg.cn/0013JKJ9jx07aaEhInRC0104010094440k01.mp4?label=mp4_hd&amp;Expires=1579700718&amp;ssig=wkpUBmK%2B9Y&amp;KID=unistore,video&quot; d:\\output.mp4 从 -i 标识的 url 下载视频保存到 output.mp4。 note: url 包含特殊字符(空格、&amp; 等)时，必须用双引号包含 url 才能正确解析；输出路径同理。","link":"/%E7%94%A8FFmpeg%E4%B8%8B%E8%BD%BD%E8%A7%86%E9%A2%91.html"},{"title":"用 FFmpeg 剪辑视频片段","text":"ffmpeg -ss 300 -t 600 -i c:\\input.mp4 c:\\output.mp4 从 input.mp4 的 300s 处开始剪辑，时长 600s，保存到 output.mp4。 note: -ss -t 参数都可应用于输入或输出(ffmpeg -i c:\\input.mp4 -ss 300 -t 600 c:\\output.mp4)上，区别在于：-ss 应用于输入时有性能优势，会先跳转到时间点再进行解码；用于输出时会逐帧解码并丢弃时间点前的所有帧。","link":"/%E7%94%A8FFmpeg%E5%89%AA%E8%BE%91%E8%A7%86%E9%A2%91%E7%89%87%E6%AE%B5.html"},{"title":"用 FFmpeg 实现画中画效果","text":"ffmpeg -i input1.mp4 -stream_loop -1 -i input2.gif -filter_complex overlay=shortest=1 output.mp4 把 gif 放在 mp4 的左上角。-stream_loop -1 指示 gif 不断循环，否则 gif 会停留在最后一帧；shortest=1 指示 overlay 操作在任意一个输入读取到文件尾时结束。 note: stream_loop 是输入项参数，所以要放在要应用的输入的后面。","link":"/%E7%94%A8FFmpeg%E5%AE%9E%E7%8E%B0%E7%94%BB%E4%B8%AD%E7%94%BB%E6%95%88%E6%9E%9C.html"},{"title":"用 FFmpeg 制作视频滚动效果","text":"ffmpeg -i input.mp4 -filter_complex &quot;split[o1][o2];[o1]select=between(n\\,0\\,100),scroll=h=0.01[oo1];[o2]select=gt(n\\,100),setpts=N/FR/TB[oo2];[oo1][oo2]concat=n=2:v=1&quot; -map 0:a output.mp4 把输入 mp4 前 100 帧做成由右到左的滚动效果。 scroll 的速率是每帧行进的视频宽/高的百分比。0.01 即每帧位移 0.01 * width 像素，所以整个滚动效果需要 100 帧。 note: 1) 第二段 select，必须从 0 重新计算 pts，否则拼接时候效果不对；2) 此法只适合短小视频操作，因为所有滤镜效果都缓存在内存；3) scroll 是 FFmpeg4.3 版本新加入的滤镜效果，用前确认版本。","link":"/%E7%94%A8FFmpeg%E5%88%B6%E4%BD%9C%E8%A7%86%E9%A2%91%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C.html"},{"title":"用FFmpeg打印音频波形图","text":"1ffmpeg -i input.mp4 -filter_complex showwavespic=s=1800x600:split_channels=1 output.jpg 把 input.mp4 里的默认音频流的采样波形图打印到 output.jpg 。s=1800x600 指定输出图片尺寸；split_channels=1 可以把多个声道分别打印一行。","link":"/%E7%94%A8FFmpeg%E6%89%93%E5%8D%B0%E9%9F%B3%E9%A2%91%E6%B3%A2%E5%BD%A2%E5%9B%BE.html"},{"title":"用 FFmpeg 录屏","text":"1ffmpeg -f gdigrab -video_size 1280x720 -offset_x 120 -offset_y 140 -show_region 1 -i desktop -c:v libx264 -preset:v ultrafast -t 10 output.mp4 从屏幕 (120,140) 像素起抓取 1280x720 尺寸的屏幕画面，时长 10 秒。-show_region 1 会在屏幕上显示一个抓取范围的矩形提示框。 note: gdigrab 只适用 Windows 系统，且只抓取画面没有声音。 FFmpeg Wiki 有关于录屏更全面的介绍。","link":"/%E7%94%A8FFmpeg%E5%BD%95%E5%B1%8F.html"},{"title":"用 FFmpeg 给 mp4 添加封面","text":"1ffmpeg -i input.mp4 -i cover.png -map 0 -map 1 -c copy -disposition:v:1 attached_pic output.mp4 将图片 cover.png 做为 input.mp4 的封面图。 关键是 -disposition:v:1 attached_pic 这句，即把 map 后的第二个视频流（ cover.png ）做为 output.mp4 的封面。","link":"/%E7%94%A8FFmpeg%E7%BB%99mp4%E6%B7%BB%E5%8A%A0%E5%B0%81%E9%9D%A2.html"},{"title":"西安行有感","text":"西安一行，让我对地方美食文化的传播有了一些自己的思考。 比如凉皮、肉夹馍，味道跟我在广州吃到的一些无异，因为本身就是大众口味，制作也简单，应该是被原样继承了下来的。 一个反例是羊杂汤。在我们老家，羊杂汤、羊肉汤在制作流程上是一样的，无非是内容差别，所以最后呈现的味道，也大体是一样的。但是在西安，羊杂汤跟羊肉汤（水盆羊肉），简直是天差地别的两个东西。所谓正宗羊杂汤的味道，怕是非少数人不可承受吧？ 但是我不知道这两个东西是不是源自一处，也不知道我们老家的羊汤是不是源自西安。也许只是我道听途说惯了，给自己错误的植入了“天下羊汤出西安”的记忆？所以这句话就当做是免责声明了吧。 总之，经历了这么多次国内旅行，我已经对正宗地道的地方菜有了免疫。在家门口吃到的，都是经过演绎变化，做成了适合你口味的罢了。好吃却在别的地方做不出来、发展不起来的菜我反而没见过。所以不必太计较于是不是正宗，更没必要对发源地心心念念。 话虽如此，对西安的失望却尤其难以抚慰，那是我念叨了小半辈子的地方……","link":"/%E8%A5%BF%E5%AE%89%E8%A1%8C%E6%9C%89%E6%84%9F.html"},{"title":"通过 HomeAssistant 查询市面上开源&#x2F;开放协议的智能家居产品小攻略","text":"HomeAssistant 是一个开源的、Python 实现的、可本地部署 的智能家居自动化服务。至今已集成了上千种智能家电、开放平台，比如 Yeelight、Opple（欧普）、Google Assistant 等等等等。 可以说，HomeAssistant 基本满足了我对智能家居中控系统的要求，尤其我一直强调的安全性问题。市面上绝大多数智能家居平台都是远程式的、不可部署的，直接引入了两大安全隐患： 数据被服务提供商有意或无意地泄漏； 数据在远程传输过程中被截取、篡改。 所以一个本地化的服务一直是我的追求。在我知道 HomeAssistant 存在之前就一直琢磨怎么利用树莓派搭建一个中控系统，无奈的是各种产品的通信协议都像一个黑盒子，无从入手。直接用 HomeAssistant 又太重。前端显示我不需要，上千种的组件我肯定也用不到，其自动化的配置方式也有学习成本。所以，我最需要的只是 HomeAssistant 的源码。 HomeAssistant 支持的产品均以组件的形式存放在 https://github.com/home-assistant/core/tree/dev/homeassistant/components 目录下，定位到某一品牌后，在其控制源码里就可以一览其实现方式。 以格力（gree）为例，在 https://github.com/home-assistant/core/tree/dev/homeassistant/components 页面搜索 gree，跳转到 ./gree 目录，点开 climate.py，有如下字样： 1234567from greeclimate.device import ( FanSpeed, HorizontalSwing, Mode, TemperatureUnits, VerticalSwing,) 像是厂商提供的一个包，去到 https://pypi.org/ 搜索包名，就找到了。文档描述其 should work for any device that also works with the Gree+ app，厉害了。 同样的方式，我也定位到了 Yeelight、Opple 这两个国内大厂的 python 包。 NGO 万岁，标准万岁，但不包括 BCI。","link":"/%E9%80%9A%E8%BF%87HomeAssistant%E6%9F%A5%E8%AF%A2%E5%B8%82%E9%9D%A2%E4%B8%8A%E5%BC%80%E6%BA%90-%E5%BC%80%E6%94%BE%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81%E5%B0%8F%E6%94%BB%E7%95%A5.html"},{"title":"智能家居产品调研备忘","text":"协议调研中发现，小米开放了一套自研的控制协议 https://github.com/OpenMiHome/mihome-binary-protocol 。对应的 python 实现在这里 https://github.com/rytilahti/python-miio 。下文提到的云仪开窗器就是采用的 miio 。miio 涉及一个 token，看了下源码，token 大概是端到端的数据加密密钥的作用，https://github.com/al-one/hass-xiaomi-miot#obtain-miio-token 这里有获取 token 方法。 灯具yeelight。控制协议完全开放，https://www.yeelight.com/download/Yeelight_Inter-Operation_Spec.pdf，有可直接使用的 python 包， https://pypi.org/project/yeelight/ 。大概看了下是参照 spec 实现的。 opple。有一个 python 包可用，https://pypi.org/project/pyoppleio/ 。但是有几年没有更新了，有一个 opened issue 提到已不能正常工作。以 homebridge opple 为关键字 google，对应插件也是年久失修状态。 飞利浦 hue。hue 是一个系列/平台，有蓝牙/网关两个子产品分类。蓝牙是直连终端，需自己 hack 其 app 获取协议；网关到终端是 zigbee 协议的，不是简单的透传，不知道咋 hack。 所以选购优先级应该是 yeelight、opple、其它。 窗帘窗帘基本上是绿米一家独大，但是绿米应该是优先级最低的选择。多数产品要么需要网关、要么走云端，很少两点一线的产品。且协议不开放，需要自己 hack。但是其到网关的协议是开放的，https://github.com/home-assistant/core/tree/dev/homeassistant/components/xiaomi_aqara 。运气好如果网关到窗帘是透传的话，倒是没问题。 其它都差不多吧。选购标准还是必须是端到端 wifi 控制的。很多所谓厂家直销的小品牌，可以尝试跟他们沟通是否可以拿到传输协议。 杜亚（dooya）。github 搜 dooya 有几个其它语言实现的 dooya 无线（433MHz）控制协议，没找到 wifi 版本。 找到一个论坛定制窗帘。https://bbs.hassbian.com/thread-4814-1-1.html，源码以 hass 插件形式开放。 米家协议窗帘。https://bbs.hassbian.com/thread-11894-1-2.html，https://github.com/tiandeyu/mijia_curtain/tree/master/custom_components 。看论坛讨论大概是所有遵循 MIoT-Spec 的窗帘设备都可以控制？这样的话选购范围就大了，基本上所有标识支持 小米APP/小爱音箱 的窗帘都可以用。 开窗器开窗器就完全是一个散乱的市场了，全是厂家定制那种。也可以尝试跟他们要协议。 云仪。https://github.com/dominic2708/yunyi_windows 。使用的是小米的协议方案。 空调格力。有 python 包，https://pypi.org/project/greeclimate/ 。homebridge 也有格力的插件，https://www.npmjs.com/package/homebridge-gree-heatercooler-v2 。都是活跃更新的，问题应该不大。 美的。有一个 HA 插件源码包，https://github.com/mac-zhou/midea-ac-py 。","link":"/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81%E8%B0%83%E7%A0%94%E5%A4%87%E5%BF%98.html"},{"title":"准备训练自己的智能家居语音助手","text":"Mozilla 实现的 DeepSpeech 语音识别引擎可以离线使用、可以运行在树莓派 4 上，简直就是给我准备的。 它附赠了一个训练好的普通话模型，我暂时没有试用。但训练自己专属的语音助手明显更带感，也更能贴近自己的说话习惯。 比如可以给它起一个很拉风的名字——贾维斯，还可以给它取几个昵称，小贾、老贾、贾爷。每当我喊出其中任何一个名字时，它都应该能识别到我是在和它说话。 市面上的语音助手，多以交互式对话完成指令。比如你问它天气预报： 1234我：小爱同学小爱同学：在我：今天几度小爱同学：今天广州 blah blah blah 这大概是对语音助手寄托了过多的私欲吧，幻想它真得会像一个朋友甚至一个红粉知己一样存在、同你交流。这方面我就理智得多了，我只希望它能完成我的指令即可。所以我会把上述对话简化成一个问答： 12我：贾维斯今天几度贾维斯：今天广州 blah blah blah 这更符合我的个性，同时也更贴合智能家居这样一个功利性极强的场景。 同时也会节省很多训练时间。依自己的说话习惯和智能家居这种词句范围有限的使用场景，训练语料应该不需要太多。","link":"/%E5%87%86%E5%A4%87%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B.html"},{"title":"Ubuntu上安装并训练DeepSpeech","text":"全程参照官方文档 ，仅少许浅坑。这篇文章算是摘要 + 翻译 + 注解吧。 前提条件 Python 3.6 严格遵守，实测 3.8 版本会有诸多错误。 Mac 或 Linux 环境 建议避过 Mac，缺失的依赖比 Linux 多很多，问题也多，我是半途放弃 Mac 转到 Ubuntu 的。可以通过启用 Windows 10 的 WSL 功能创建 Ubuntu 环境，可以使用所有的硬件能力。 CUDA 10.0 / CuDNN v7.6 per Dockerfile. 这条为非必须，因为我是新手，直接用 CPU 训练的。 下载 DeepSpeech 源码1git clone --branch v0.9.3 https://github.com/mozilla/DeepSpeech 创建 Python 虚拟环境使用默认的 venv 方式创建： 1python3 -m venv ~/tmp/deepspeech-train-venv/ 激活虚拟环境source ~/tmp/deepspeech-train-venv/bin/activate 然后下边的所有操作都应该在此虚拟环境中进行。 安装 DeepSpeech 依赖123cd DeepSpeechpip3 install --upgrade pip==20.2.2 wheel==0.34.2 setuptools==49.6.0pip3 install --upgrade -e . 后续如果有更新 DeepSpeech 源码，需要再次执行上边最后一句 pip3 install 命令，确保依赖对得上号。 这个过程中会遇到一个错误： 12345ERROR: After October 2020 you may experience errors when installing or updating packages. This is because pip will change the way that it resolves dependency conflicts.We recommend you use --use-feature=2020-resolver to test your packages with the new resolver before it becomes the default.tensorflow 1.15.4 requires numpy&lt;1.19.0,&gt;=1.16.0, but you'll have numpy 1.19.5 which is incompatible. 依照错误提示卸载 numpy 再装一个指定版本的包即可： 123pip3 uninstall numpypip3 install numpy==1.16.0pip3 install tensorflow==1.15.4 然后安装一个 webrtcvad 的依赖包： 1sudo apt-get install python3-dev 执行 DeepSpeech 预置脚本完成一次简单训练跳转到 DeepSpeech 根目录 后执行以下脚本： 1./bin/run-ldc93s1.sh 上边脚本会下载语料，处理成 DeepSpeech 可识别格式，然后进行训练。下载的语料和处理后的数据都保存在 DeepSpeech/data/ldc93s1/ 目录下。 DeepSpeech 要求必须用 16 bit 位深、单声道的音频进行训练、识别；且训练与识别所用的音频的采样率也必须相同。 几分钟就训练完了。但是这个脚本没有将训练后的模型保存成文件，可以打开脚本，给在最后边执行的 DeepSpeech.py 脚本添加一个参数： 12345678910python -u DeepSpeech.py --noshow_progressbar \\ --train_files data/ldc93s1/ldc93s1.csv \\ --test_files data/ldc93s1/ldc93s1.csv \\ --train_batch_size 1 \\ --test_batch_size 1 \\ --n_hidden 100 \\ --epochs 200 \\ --checkpoint_dir &quot;$checkpoint_dir&quot; \\ --export_dir /mnt/g/ \\ # 这行就是新添加的，可以将模型保存到指定目录 &quot;$@&quot; 在 /mnt/g/ 目录下会生成一个 output_graph.pb 模型文件。 使用 Mozilla 提供的数据集Mozilla 收集了很多语言的数据集，包括普通话 。下载下来的是一个 tar 压缩包，解压后得到一串 clips/*.mp3 文件和若干 tsv 文件。 执行 bin/import_cv2.py 脚本： 1bin/import_cv2.py /path/to/extracted/language/archive 在 clips 目录下创建了 mp3 对应的 wav 文件，和若干 csv 文件。这些就是 DeepSpeech 可识别的输入了，参照上边 run-ldc93s1.sh 中 DeepSpeech.py 脚本的用法，就可以用这些数据集训练了。","link":"/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E8%AE%AD%E7%BB%83DeepSpeech.html"},{"title":"自定义语音助手语料设计","text":"旺财 客厅 卧室 书房 窗帘 窗户 空调 灯 开 关 开灯 关灯 开窗帘 关窗帘 开窗户 关窗户 开空调 关空调 旺财开灯 旺财开客厅灯 旺财把客厅灯打开 旺财关窗帘 旺财关客厅窗帘 旺财把客厅窗帘关上 旺财开窗帘 旺财开客厅窗帘 旺财把客厅窗帘打开 旺财开空调，二十五度 旺财开窗户 旺财开客厅窗户 旺财把客厅窗户打开 旺财关窗户 旺财关客厅窗户 旺财把客厅窗户关上 旺财开卧室灯 旺财把卧室灯打开 旺财关卧室窗帘 旺财把卧室窗帘关上 旺财开卧室窗帘 旺财把卧室窗帘打开 旺财开卧室窗户 旺财把卧室窗户打开 旺财关卧室窗户 旺财把卧室窗户关上 旺财开书房灯 旺财把书房灯打开 旺财关书房窗帘 旺财把书房窗帘关上 旺财开书房窗帘 旺财把书房窗帘打开 旺财开书房窗户 旺财把书房窗户打开 旺财关书房窗户 旺财把书房窗户关上","link":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AF%AD%E9%9F%B3%E5%8A%A9%E6%89%8B%E8%AF%AD%E6%96%99%E8%AE%BE%E8%AE%A1.html"},{"title":"DeepSpeech 调参备忘","text":"最优解迄今为止训练效果最好的一组参数集是： 1python DeepSpeech.py --train_files /mnt/g/myowncorpus/dst.csv --dev_files /mnt/g/myowncorpus/dst.csv --export_dir /mnt/g/myowncorpus/ --checkpoint_dir /mnt/g/myowncorpus/checkpoints128 --alphabet_config_path /mnt/g/myowncorpus/alphabet.txt --dropout_rate 0.3 --early_stop True --n_hidden 128 --export_file_name hidden128 --export_author_id hidden128 --epochs 200 --export_model_version 0.0.3 --lm_alpha 0.6940122363709647 --lm_beta 4.777924224113021 --export_language cmn-Hans-CN --reduce_lr_on_plateau False --es_epochs 800 --test_files /mnt/g/myowncorpus/dst.csv --learning_rate 0.001 --beam_width 100 checkpoint_dir checkpoint 路径。checkpoint 是一种增量训练机制，允许保存之前最近的、最优的若干次训练结果，下一次加载后继续训练。 n_hidden 隐含层数量。对隐含层解释地比较通俗易懂的是这篇文章 。直接影响有 3 个： 1) 训练速度，越小越快 2) 模型文件尺寸，值越小文件尺寸越小 3) 训练效果，无绝对好坏，取决于训练集。我是从默认的 2048 一直减半到现在的 128 测试出来的最优值。 调整 hidden 必须从头训练，不能沿用之前的 checkpoint 。 alphabet_config_path 字母表。中文训练即训练集中出现的所有汉字的集合。 dropout_rate 随机丢掉隐含层的比例。 epochs 训练次数。不是越多越好，反而有可能变坏。像我现在数据集只有 113 条，最佳的训练次数是 200 次。 lm_alpha lm_beta 语言模型参数，取值是官方推荐值。 问题总是有若干条目识别特别差，最典型的是这个： 语音：旺财关客厅窗帘 文本：旺财把客厅窗帘 语音：旺财开书房灯 文本：旺财把书房灯 调试了各种参数还是不能解决。怀疑跟数据集太小、相关录音录制得不清楚有关系。 参考 隐藏层：https://blog.csdn.net/JH0lmes/article/details/82777269 CNN 入门讲解：什么是dropout?：https://zhuanlan.zhihu.com/p/77609689 https://github.com/mozilla/DeepSpeech/releases/tag/v0.9.3","link":"/DeepSpeech%E8%B0%83%E5%8F%82%E5%A4%87%E5%BF%98.html"},{"title":"智能家居终端控制系统设计","text":"手里有闲置的 Surface 3 平板、Android 平板、Android 手机各一台，正好可以把它们分散固定在常驻区域的墙面上，一可以用作多媒体终端（这个功能是现成的），二就是可以用作智能家居的控制终端，和我的树莓派（中控系统）进行双工通信。 这是我设想的语音助手外的另一个重要的控制路径。比如，你已经在终端附近时，或超出拾音范围时，或者你恰巧在一直嗡嗡响的洗衣机周边时，通过屏幕终端下发命令应该是更优解。 3 个固定的终端大概是分别放在厨房、客厅、阳台。树莓派作为服务端，允许多个客户端的接入，推送设备状态信息到所有终端。最终的网络连接很可能不是图里这种 all to all 的结果，因为我很可能有两段路由。 终端的软件实现，大致确定以 web 页面形式实现，否则分别开发原生应用的代价太大了。前端框架用 React，小巧、组件化实现，上手简单；搭配 Spectre CSS 库，开发一个看起来差不多的 UI 应该是够了。 网络传输自然是 Websocket 了，树莓派是服务端，各个终端是客户端。因为是局域网传输，数据量也不大，所以应该直接传输 json 数据。具体的数据模型待定，跟最后选定的家电的能力强关联，现在写得太细也没什么意义。 待续…","link":"/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E7%BB%88%E7%AB%AF%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html"},{"title":"通过人体识别实现智能家居控制","text":"市面上普遍使用的人体检测方案是红外传感器，缺点很多且显得特别弱智： 只能检测运动物体； 完全不能区分人或其它活动物体； 不能区分人体是进入或离开某一区域。 设想一个最简单普遍的生活场景：当我晚上 7 点步入餐厅时，餐厅灯光应随之亮起；同理，当识别到餐厅无人时，应自动将餐厅灯关闭。通过人体传感器是死活做不到这点的。 转换思路，视餐厅为一平面图，上述问题即可抽象成 “如何检测一张图片内是否有人存在”，解决方案就显而易见了——目标检测。 识别算法YOLOv5 没能部署到树莓派上（官方 32 位系统），也没深究。转头发现了 Paddle-Lite ，专为移动端、嵌入式硬件开发的深度学习推理框架。Paddle 提供了超多预训练模型 ，我选取了其中尺寸最小的MobileNetV3 Small ，实测在树莓派4 上每次推理仅需 &lt; 200 ms。 摄像头这甚至是个比识别率还严重的问题。基本上所有的 USB 摄像头都不具备夜视能力，用这种摄像头正应了达文西手电筒的梗。无奈买了一个网络摄像头，因为需通过 RTSP 协议获取视频流，缺点同样明显： 占用宽带； 高延时； 需要解码。 所以我现在设定的采集帧率仅为 2 帧/秒，尽量降低树莓派的功耗。 问题 识别速度。 暂时没找到只一个人体分类的模型，这是推理速度的一个瓶颈。终极方案大概只能是自己训练模型。 识别正确率。 一个是模型没有按场景训练过；一个是单一摄像头角度固定，需要一个摄像头阵列从不同角度采集后综合得出是否有人的最终结论。这不管是从经济角度还是技术角度，都是个大工程。 视频采集延时。 得继续找一个更靠谱的摄像头，至少 3 米的夜视能力是基本要求，USB 有线是最好的了。现有的网络摄像头方案，大概可以通过把摄像头和树莓派都有线连接到路由器降低延时。 源码(https://github.com/LiangZuoting/PersonMonitor) 。PersonMonitor 把识别结果推送到 SmartHome Web API，SmartHome 控制灯具做出响应。 后续摄像头问题已完美解决。 在 1688 上淘到了这个 USB 接口的夜视摄像头。 深究之后发现，摄像头延时问题除 RTSP 协议原因外，还有一个很重要的点是 OpenCV 会默认缓存 4-5 帧图像。解决方案就是把摄像头采集放在单独线程里进行，且采集速度应明显高于识别速度。比如我的设定是每 200ms 识别一次，每 100ms 采集一次，利用 100ms 的时间差尽可能丢掉前边的缓存帧，只保留最新的一帧。这样，识别也是基于最新帧了。","link":"/%E9%80%9A%E8%BF%87%E4%BA%BA%E4%BD%93%E8%AF%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E6%8E%A7%E5%88%B6.html"},{"title":"Sanic 还不错","text":"简单横向比较了 Sanic、Flask、FastAPI 之后，决定以后还是优先学 Sanic 吧。 Sanic 在同类评测里名列前茅。异步架构有先天的性能优势，Flask 甚至才认识到这点，好像又显得不那么重视。最新发布的 2.x 版本里的异步支持形同鸡肋，不支持 ASGI，不支持后台任务，Websocket 也同样不能支持。 当红炸子鸡 FastAPI 性能同样表现优异，写代码还送文档，着实吸睛，但是那 600 多个 issue 令我“望而生畏”。 模版支持对我反倒是减分项。我是前后端分离的忠实信徒，Sanic 这种一刀切的做法正和我胃口，有事抛 request 过来，合理的性能损耗完全是可以接受的。 Sanic 不只是开发框架，同时提供了产品级的 ASGI 服务器，对新人比较友好，部署上也能省点事，这是 FastAPI 也没能做到的一点。 一些细节上的做法 Sanic 也同样很合我意。比如 request 对象必须做为 view 函数第一个参数进行显式传递。相比 Flask Thread Local 的实现方案，这个额外的参数更像是设计合理的必然结果，因为借此你可以直观地获知 request 对象的生命周期。强制要求 view 返回 HTTPResponse 对象也同具此意。 这几天翻阅了不少 Python Web 框架的文档，最直观感受就是太卷了。如果分别用这些框架实现同样一个功能，查重率应该不会低于 80% 吧？","link":"/Sanic%E8%BF%98%E4%B8%8D%E9%94%99.html"},{"title":"外链 Jellyfin 视频播放页地址","text":"我自己的检索服务本人珍藏的视频比较多，有 TB 级别，所以之前我通过人工给视频文件打 tag 的方式，自创了一套文件检索系统。比如： 1snis243_吉川爱美_单体_好身材_漂亮.mp4 这样一个文件名，约定以下划线分隔 tag，且第一个 tag 总是视频标题。 生成检索数据库后，我用 Sanic + React 实现了 B/S 结构的检索服务。 首页展示所有的 tag： 检索结果页列出所有的匹配视频： 因为是在本地播放，Windows 上有比较万能的播放器，所以当时就没做转码服务，直接用默认浏览器播放选中视频即可。 这套系统很符合我个人阅片习惯，可以依着自己当时的心情按 tag 选片。 把 Jellyfin 和检索服务结合起来6.18 入手了群晖 NAS，支持 Docker。赶紧把电脑上珍藏了好久的视频资源拷贝到了 NAS 上一份，也学别人在 Docker 上用 Jellyfin 搭建了个视频播放服务。 但是 Jellyfin 不识别我的 tag 约定，我的检索系统又没有转码播放服务，两边都用得不顺手。就想到把两边的功能结合一下，用检索系统选片后，跳转到 Jellyfin 的视频详细页面，利用 Jellyfin 播放视频。 Jellyfin 视频页面的地址格式如下： 1http://192.168.3.34:8096/web/index.html#!/details?serverId=xxxxxx&amp;id=xxxxxxxx serverId id 都是一个 32 字符的字符串，serverId 值可以视为一个常量，硬编码到代码里即可。难的是 id 参数值的规则。 最终通过翻阅 Jellyfin 源码，发现所有媒体信息都存储在 library.db 的 sqlite 数据库中，在一个叫 TypedbaseItems 的表里，存储了视频文件路径到 PresentationUniqueKey 的映射关系，这个 PresentationUniqueKey 就是 id。 直接把我生成检索数据库的 generator.py 改掉，无需再遍历文件系统，通过读取 library.db 就满足需求了。 至此，当我在自己的检索服务中选中某项后，就可以跳转到视频对应的 Jellyfin 页面了。 小小后记最开始盲猜 serverId id 都是 md5 或其它摘要算法的产出，在 Jellyfin 源码里一顿全局搜索，浪费了一些时间。后来才想到可以直接查阅它的数据库，”暴破”文件到 id 的映射。事后才发现，id 是 Guid 来的，根本不是通过对文件信息摘要所得。","link":"/%E5%A4%96%E9%93%BEJellyfin%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E9%A1%B5%E5%9C%B0%E5%9D%80.html"},{"title":"视频编辑器 ffcutter","text":"ffcutter 初版写完有段日子了。本想着把功能再丰富下， UI 规范后再开源，无奈此后一连数月都忙于新家的智能家居系统的设计开发，ffcutter 就淡忘了。就以现状开源了吧，献给有缘人 。 项目地址 开发环境 C++17 Qt 5.15 FFmpeg 4.3.1 Visual Studio Community 2019 代码结构 如上图，核心能力以 fccore 动态链接库形式提供，FCService 为接口类。对 FFmpeg 各个功能模块再做一层类封装，简化操作步骤，方便复用。 类名均以 FC 为前缀，取自 Fast forword Cutter。 功能介绍快速跳转跳转到指定时间戳后的第一个关键帧。 所谓快速，即只解封装，不解码。对 h264 等帧间编码格式，只有关键帧是内容自足的，B 帧、P 帧的图像内容均依赖相邻帧共同还原。 具体技术细节可参考 FFmpeg AVSEEK_FLAG_BACKWARD 文档。 精确跳转跳转到不晚于指定时间戳后的第一帧。 跳转耗时同 GOP 大小有很大关系。如果恰好需要跳转到某一关键帧之后的一帧，就需要解码 GOP - 1 帧。 通过预览图快速确定视频截取的起止时间左键双击预览图，使用预览图对应帧的时间戳填充起始时间编辑框；右键双击，快速填充结束时间编辑框。 如要截取 jpg 等静态图，左键双击要截取的帧，右键双击下一帧。 文字文字以 FFmpeg drawtext Filter 实现，支持 文本表达式 以显示动态内容，但为了简化使用方式，只支持全视频添加固定文字，不支持指定时间段。 文字支持自选字体，作者存放于 repo 中的几种字体，仅为测试之用，请在使用前确认其授权形式。 字幕以 FFmpeg subtitles Filter 实现，支持 srt ass 等格式。除支持复杂的时间戳规则外，字幕同文字另一个不同的地方在于，字幕是以流（stream）的形式存储于容器文件中的，而非修改视频帧，将文字绘制于上。 自定义滤镜理论上支持所有其它 FFmpeg Filter，语法同 ffmpeg.exe，ffcutter 会将其拼接到上边所列 Filter 之后。 不足之处UI 简陋敝人区区一草莽大汉，于此精巧之工，实无能为力也~ 产品思路感人没有时间线的概念，不能预览全视频；没有视频回放；没有基于音频的剪辑。 多段剪辑、拼接一次只能剪辑一个片段。理想的情况下，应支持多段视频剪辑，然后内存中直接拼接成一个视频。","link":"/%E8%A7%86%E9%A2%91%E7%BC%96%E8%BE%91%E5%99%A8ffcutter.html"},{"title":"C++17 详解 2","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 1. 修复和弃用C++17 标准现在有超过 1600 页，比 C++14 多出了 200 多页。幸运的是，语言规范在一些地方得到了清理，一些老旧的或潜在的坏特性随之被清除。 本章你将学到： 从语言中删除了什么，比如：register 关键字，auto_ptr 和 std::random_shuffle。 已弃用并会在未来版本被删除的内容。 修复内容，尤其是对“花括号初始化”（brace initialisation）的自动类型推导。 1.1 删除内容每次 C++ 版本迭代，其中一个核心概念就是和旧版本的兼容性。我们期待语言中出现新东西，同时我们的老工程应该仍然能编译通过。尽管如此，有时候这也是一个删除极少用到或错误部分的机会。 译注：老外说话有时候就是别别扭扭，不够直接。上边这段话大概就是“向下兼容当然是首要的，但有时候不得不删除一些很少用到的或者是错误的东西”的意思。 本节简要说明从标准中删除的内容。 1.1.1 删除 auto_ptr可能是最好的消息了！ C++98 加入 auto_ptr，做为对原生指针支持基本的 RAII 特性的手段。但是，由于当时语言中缺少移动语义，auto_ptr 很容易被误用从而导致运行时错误。 这里是一个 auto_ptr 可能导致崩溃的例子： 123456789101112// Chpater Fixes And Deprecation/auto_ptrCrash.cppvoid doSomething(std::auto_ptr&lt;int&gt; myPtr){ *myPtr = 11;}void AutoPtrTest() { std::auto_ptr&lt;int&gt; myTest(new int(10)); doSomething(myTest); *myTest = 12;} doSomething() 通过传值参数拿到指针，但是 auto_ptr 不是共享型指针（shared pointer），所以它拿到了被管理对象的唯一所有权。当函数执行完毕，pyPtr 走完生命周期，指针对象被删除。 在 AutoPtrTest() 中，当 doSomething 结束时指针对象已经被删除了，接下来（译注：*myTest = 12;）你会触发未定义行为（undefined behavior），甚至可能崩溃。 译注：原文 maybe even a crash!。实际触发 ub 时，崩溃可能是最好的结果了，很大程度免去了把 bug 带到线上的痛苦。 到 C++11，我们有了智能指针：unique_ptr、shared_ptr 和 weak_ptr。配合移动语义，C++ 终于可以正确支持唯一资源的转移了。而且新的智能指针可以被存储在标准容器内，auto_ptr 是不支持的。你应该用 unique_ptr 替换掉 auto_ptr，因为它是 auto_ptr 直接的、最好的对等物。 新的智能指针相比 auto_ptr 更强大更安全，所以从 C++11 起 auto_ptr 已经被标记为已弃用。编译器会报出一个 warning： warning: 'template&lt;class&gt; class std::auto_ptr' is deprecated 现在，如果你用一个合规的 C++17 编译器编译，它会报出一个 error。 这是启用 /std:c++latest 选项的 MSVC 2017 报出的 error： 1error C2039: 'auto_ptr': is not a member of 'std' 如果你需要从 auto_ptr 转换到 unique_ptr 的帮助，可以查阅 Clang Tidy，它提供了自动转换： Clang Tidy: modernize-replace-auto-ptr。 译注：Clang-Tidy 是一套基于 Clang 的静态检查工具，其中一项功能就是自动替换 auto_ptr。 扩展：本修改提案：N4190。","link":"/C++17%E8%AF%A6%E8%A7%A32.html"},{"title":"C++17 详解 1","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 第一部分——语言特性C++17 是对 C++ 的一次重大更新，引入了大量语言特性。大多数新增特性让 C++ 更简洁更直截了当。 在本部分你将学到： 被移除和被标记为已弃用的特性 C++ 是如何变得更精准的：比如，借助表达式求值顺序保证 模版相关新特性：比如 if constexpr、折叠表达式（fold expressions） 新的标准属性（attributes） 如何借助结构化绑定（structured binding）、内联变量（inline variables）、编译时 if 和类模版参数推导（template argument deduction for classes）写出更简洁更具表现力的代码 快速开始为了激发你对新标准更多的好奇心，下面展示几段新特性组合使用的代码示例。 如果觉得示例太复杂也不用担心，因为它们把太多新东西混在了一起。所有新特性都会在接下来的章节进行单独深入解释。 使用 Map123456789101112131415// Example: Part I/demo_map.cpp#include &lt;iostream&gt;#include &lt;map&gt;int main() { std::map&lt;std::string, int&gt; mapUserAge{ {\"Alex\", 45}, {\"John\", 25} }; std::map mapCopy{ mapUserAge }; if (auto [iter, wasAdded] = mapCopy.insert_or_assign(\"John\", 26); !wasAdded) std::cout &lt;&lt; iter-&gt;first &lt;&lt; \" reassigned...\\n\"; for (const auto &amp;[key, value] : mapCopy) std::cout &lt;&lt; key &lt;&lt; \", \" &lt;&lt; value &lt;&lt; '\\n';} 代码输出如下： 123John reassigned...Alex, 45John, 26 上边示例使用了如下特性： 第 8 行：类模板参数推导—— mapCopy 类型从 mapUserAge 类型推断得来。不需要显式声明为 std::map&lt;std::string, int&gt; mapCopy{...}。 第 10 行：新的 map 插入函数—— insert_or_assign。 第 10 行：结构化绑定——捕获 insert_or_assign 返回的 pair 到两个分开的变量。 第 10 行：带初始化的 if 语句—— iter、wasAdded 只在 if 语句代码块内可见。 第 13 行：基于范围的 for （range-based for）循环内的结构化绑定——可以用 key 和 value 代替 pair.first pair.second 进行迭代。 调试打印123456789101112131415161718192021222324252627// Example: Part I/demo_print.cpp#include &lt;iostream&gt;template&lt;typename T&gt; void linePrinter(const T &amp;x) { if constexpr (std::is_integral_v&lt;T&gt;) std::cout &lt;&lt; \"num: \" &lt;&lt; x &lt;&lt; '\\n'; else if constexpr (std::is_floating_point_v&lt;T&gt;) { const auto frac = x - static_cast&lt;long&gt;(x); std::cout &lt;&lt; \"flt: \" &lt;&lt; x &lt;&lt; \", frac \" &lt;&lt; frac &lt;&lt; '\\n'; } else if constexpr (std::is_pointer_v&lt;T&gt;) { std::cout &lt;&lt; \"ptr, \"; linePrinter(*x); } else std::cout &lt;&lt; x &lt;&lt; '\\n';}template &lt;typename ... Args&gt; void printWithInfo(Args ... args) { (linePrinter(args), ...); // 逗号运算符上的折叠表达式}int main() { int i = 10; float f = 2.56f; printWithInfo(&amp;i, &amp;f, 30);} 代码输出如下： 123ptr, num: 10ptr, flt: 2.56, frac 0.56num: 30 这里用到了以下特性： 第 5、7、11 行：if constexpr ——用于匹配模版参数，以使编译时丢弃代码。 第 5、7、11 行：类型萃取中 _v 样式的变量模版——不再需要写明 std::trait_name&lt;T&gt;::value。 第 20 行：printWithInfo 内的折叠表达式——此特性简化了可变参数模版。本例中我们对所有输入参数分别调用 linePrinter()。 正式开始吧！上边你看到的只是冰山一角，阅读接下来的章节你会看到更多：对当前语言的修复、阐明、移除（比如 auto_ptr），当然还有新增的一些东西：constexpr lambda，if constexpr，结构化绑定，template&lt;auto&gt;，内联变量，类模板参数推断以及更多。","link":"/C++17%E8%AF%A6%E8%A7%A31.html"},{"title":"C++17 详解 3","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 1.1.2 删除关键字 register关键字 register 在 2011 年（C++11）被弃用，自那以后 register 已经没有意义，现在它被删除。这个关键字仍然被保留，有可能会在未来某个版本重新设计意图（比如关键字 auto 就是复用而来，现在它是一个全新的、更强大的特性）。 如果你用 register 声明变量： 1register int a; 可能会产生如下 warning（GCC8.1）: 1warning: ISO C++17 does not allow 'register' storage class specifier 或是 Clang 的一个 error（Clang 7.0）： 1error: ISO C++17 does not allow 'register' storage class specifier 扩展：本修改提案：P0001R1 1.1.3 删除弃用的 operator++(bool)这个操作符已经被弃用很久了。标准委员会早在 1998 年（C++98）就建议不要使用，但直到现在他们才达成一致，把它从标准里删除。 译注：C++ 标准委员会出了名的松散、低效，学院气十足。此处即可见一斑，遑论如网络库、协程库等模块级的更新效率。 如果你尝试编译如下代码： 12bool b;b++; 会生成像下边 GCC（GCC 8.1）类似的 error： 1error: use of an operand of type 'bool' in 'operator++' is forbidden in C++17 扩展：本修改提案：P0002R1 1.1.4 删除弃用的异常规范C++17 里，异常规范是类型系统的一部分（在下一章“语言声明”有讨论）。但是标准还是保留了以前被弃用的异常规范，只是没有实际作用。 比如： 12345void fooThrowsInt(int a) throw(int) { printf_s(\"can throw ints\\n\"); if (a == 0) throw 1;} 请特别留意 throw(int)。 上边的代码在 C++11 已经被弃用，现在唯一可行的异常声明是 throw()，意思是这段代码绝不会抛出任何异常。C++11 起建议用 noexcept 代替。 比如 clang 4.0 里会生成如下 error： 12error: ISO C++1z does not allow dynamic exception specifications[-Wdynamic-exception-spec] note: use 'noexcept(false)' instead 扩展：本修改提案：P0003R5 1.1.5 其它被删除的特性这里列出其它被删除的比较小的内容： std::random_shuffle 此算法在 C++14 已被标记为弃用。原因是大多数的实现里都用到了 rand()，这个函数不够高效甚至容易出错（因为它用到了全局状态）。如果你需要同样的功能可以用： 12template&lt; class RandomIt, class URBG &gt;void shuffle( RandomIt first, RandomIt last, URBG&amp;&amp; g ); std::shuffle 接受一个随机数生成器作为第三个参数。更多参见 N4190。 删除旧的 functional 相关 bind1st() / bind2st() / mem_fun() 等这些函数，在 C++98 时代被引入，现在已经不需要了，你可以用 lambda。更重要的是，这些函数没有更新以处理完美转发、decltype 以及其它 C++11 以来的现代化技术。因此最好不要在现代 C++ 里用它们。更多参见 N4190。 删除三标符（trigraphs） 三标符是一种特殊的字符序列，在一些不支持 7-bit ASCII 码的系统（比如 ISO 646）上有用。比如 ??= 生成 #，??- 代表 ~（所有 C++ 源代码字符集都包含在 7-bit ASCII 码中）。在今天三标符已经很少用到，把它从翻译阶段移除，编译处理会更直截了当。参见 N4086。 译注：阅读本书之前，我完全不知道三标符的存在，只能勉强翻译。除上边草案外，还可以参考这里。","link":"/C++17%E8%AF%A6%E8%A7%A33.html"},{"title":"C++17 详解 4","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 1.2 修复（Fixes）修复的定义是有争论的。下边 3 条应该算是对在之前规则下缺失、不能正常工作的内容的修复。 1.2.1 直接列表初始化上 auto 的新规则C++11 起引入了一个奇怪的问题： 1auto x{ 1 }; 被推断为 std::initializer_list&lt;int&gt;。大多数情况下这个行为不是本意，你原本期望它像 int x{ 1 }; 一样工作。花括号初始化是现代 C++11 里首推的初始化样式，但是这种异常让这个特性变弱了。 在新标准里，我们可以修复它，以使它被推断为 int。 若要如此，我们需要理解两种初始化方式——拷贝（初始化）和直接（初始化）： 12345auto x = foo(); // 拷贝初始化auto x{foo()}; // 直接初始化, 初始化为 initializer_list (until C++17)int x = foo(); // 拷贝初始化int x{foo()}; // 直接初始化 C++17 为直接初始化引入了两条新规则： 对只有一个元素的花括号初始化列表，auto 推断会根据列表项推断； 对包含多于一个元素的花括号初始化列表，auto 推断是非良构的。 译注：非良构（ill-formed）代码即错误代码，会导致编译错误。 举几个例子： 12345auto x1 = { 1, 2 }; // decltype(x1) 值为 std::initializer_list&lt;int&gt;auto x2 = { 1, 2.0 }; // error: cannot deduce element typeauto x3{ 1, 2 }; // error: not a single elementauto x4 = { 3 }; // decltype(x4) 值为 std::initializer_list&lt;int&gt;auto x5{ 3 }; // decltype(x5) 值为 int 扩展： 本修改提案：N3922、N3681。编译器很早就修复了这个问题，GCC 5.0 （2015 年中）、Clang 3.8（2016 年初）、MSVC 2015（2015 年中）里此项改进就已可得，远早于 C++17 被批准。 1.2.2 不带消息体的 static_assert本特性新加了一个 static_assert 的重载版本，允许你只通过条件使用 static_assert 而不用传递消息参数。 它和其它的断言实现兼容，比如 BOOST_STATIC_ASSERT。有 boost 经验的程序员可以很容易切换到 C++17 的 static_assert。 12static_assert(std::is_arithmetic_v&lt;T&gt;, \"T must be arithmetic\");static_assert(std::is_arithmetic_v&lt;T&gt;); // C++17 起不再需要消息体 大多数情况下，条件本身就已足够表达意图，无需在消息字符串中再提及。 扩展：本修改提案：N3928。 1.2.3 range-based for 循环中使用类型不同的 begin 和 endC++11 引入了 range-based for 循环： 1234for (for-range-declaration : for-range-initializer){ statement;} 根据标准，这种循环表达式等同于如下代码： 123456789{ auto &amp;&amp; __range = for-range-initializer; for ( auto __begin = begin-expr, __end = end-expr; __begin != __end; ++__begin ) { for-range-declaration = *__begin; statement }} 如你所见，__begin 和 __end 类型相同。这样能很好地工作，但是伸缩性不够。比如你可能会想一直迭代到某个跟范围起点类型不同的哨兵。 C++17 里它被改为： 123456789{ auto &amp;&amp; __range = for-range-initializer; auto __begin = begin-expr; auto __end = end-expr; for ( ; __begin != __end; ++__begin ) { for-range-declaration = *__begin; statement }} __begin 和 __end 的类型不一样，只有比较操作符是必要的。这个改动对 for 的使用者没有任何可见的后果，但是对库的实现多了更多选择。比如，这个小改动允许 Range 技术规范（C++20 中的 Ranges）可以和 range for 循环一起工作。 扩展：本修改提案：P0184R0。 1.3 编译器支持略。 译注：懒得翻译了，到今天 C++17 已经被三大编译器厂商支持了 N 年了。","link":"/C++17%E8%AF%A6%E8%A7%A34.html"},{"title":"C++17 详解 5","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 2. 语言阐明学习并完全理解 C++ 是很有挑战的，许多地方都让程序员很疑惑。缺乏明确行为的一个原因，可能是赋予了编译器实现自由选择的权利。比如，允许更激进的优化，或者为了向后兼容（或者兼容 C）的需要。C++17 回顾了几个最出名的“黑洞”并把它们做了处理。 本章你将学到： 什么是求值顺序，求值顺序为什么会导致非预期结果。 复制消除（一种可选的优化手段，似乎在所有流行编译器上都已被实现。） 异常作为函数声明的一部分。 （过度）对齐数据的内存分配。 2.1 更严格的表达式求值顺序C++17 之前标准一直没有明确规定函数参数的求值顺序。呜呼哀哉。 比如，这也是为什么说在 C++14 里 make_unique 不只是语法糖的原因，它还保证了内存安全： 看下边这个例子： 1foo(make_unique&lt;T&gt;(), otherFunction()); 和显式 new 版本： 1foo(unique_ptr&lt;T&gt;(new T), otherFunction()); 上边代码在 C++14 里，我们知道 new T 被保证会在 unique_ptr 构造之前执行，不过也仅此而已。new T 可能会率先执行，然后是 otherFunction()，最后才是 unique_ptr 构造。 当 otherFunction() 抛出异常，new T 就会导致一次内存泄漏（智能指针对象还没有创建）。但如果你用的是 make_unique，它不可能导致内存泄漏，即使执行顺序未知。 C++17 解决了这个问题，现在属性的求值顺序是“实用的”、可预测的。 译注：原文为 “C++17 addresses this issue, and now the evaluation order of attributes is “practical” and predictable.” 2.1.1 示例在如下表达式里： 1f(a, b, c); a b c 的求值顺序依然不明确，但是任一参数都会在下一个参数执行前被全部计算。这点在如下的复杂表达式里至关重要： 1f(a(x), b, c(y)); 当编译器决定计算第一个参数 a(x) 时，同样需要在处理 b 或 c(y) 之前计算 x。 它同样修复了上边 make_unique 和 unique_ptr&lt;t&gt;(new T()) 的问题——因为函数参数必须在其它参数开始执行前被完全求值。 考虑下边的情况： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;class Query{ public: Query&amp; addInt(int i) { std::cout &lt;&lt; \"addInt: \" &lt;&lt; i &lt;&lt; '\\n'; return *this; } Query&amp; addFloat(float f) { std::cout &lt;&lt; \"addFloat: \" &lt;&lt; f &lt;&lt; '\\n'; return *this; }};float computeFloat(){ std::cout &lt;&lt; \"computing float... \\n\"; return 10.1f;}float computeInt(){ std::cout &lt;&lt; \"computing int... \\n\"; return 8;}int main(){ Query q; q.addFloat(computeFloat()).addInt(computeInt());} C++14 里，你可能会期望 computeInt() 后于 addFloat() 执行。不幸的是它有可能不是这样执行。下边是 GCC 4.7.3 的输出： 1234computing int...computing float...addFloat: 10.1addInt: 8 函数调用链被明确规定为自左向右，但是内层的表达式的求值顺序是可能不一样的。更准确地来说： 表达式间的相互顺序是不确定的。 译注：原文为 “The expressions are indeterminately sequenced with respect to each other.”。 不过现在，在 C++17 里，包含嵌套表达式的函数调用链会如期运行，即自左向右： 在如下表达式里： 1a(expA).b(expB).c(expC) expA 会先于 b 执行。 用一个合规的 C++17 编译器编译上边的示例代码，会生成如下结果： 1234computing float...addFloat: 10.1computing int...addInt: 8 本次修改的另一个结果是，当进行操作符重载时，其执行顺序取决于原本内置操作符的关联性。 这也是为什么 std::cout &lt;&lt; a() &lt;&lt; b() &lt;&lt; c() 会按 a b c 顺序执行的原因。C++17 之前，它可以是任意执行顺序。 下边是标准描述的更多规则： 下列表达式均按先 a 后 b 的顺序计算： a.b a-&gt;b a-&gt;*b a(b1, b2, b3) // b1, b2, b3 - 任意顺序 b @= a // '@' means any operator a[b] a &lt;&lt; b a &gt;&gt; b 如果你不确定自己的代码如何被计算，你最好做一次简化，把代码拆成多个清晰的语句。你可以在《Core C++ Guidelines》里找到指导，比如ES.44¹ 和 ES.44²。 扩展：本修改提案：P0145R3。","link":"/C++17%E8%AF%A6%E8%A7%A35.html"},{"title":"C++17 详解 6","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 2.2 有保证的复制消除复制消除是一种流行的优化手段，它可以避免创建不必要的临时对象。 比如： 1234567891011121314151617181920// Chapter Clarification/copy_elision.cpp#include &lt;iostream&gt;struct Test{ Test() { std::cout &lt;&lt; \"Test::Test\\n\"; } Test(const Test&amp;) { std::cout &lt;&lt; \"Test(const Test&amp;)\\n\"; } Test(Test&amp;&amp;) { std::cout &lt;&lt; \"Test(Test&amp;&amp;)\\n\"; } ~Test() { std::cout &lt;&lt; \"~Test\\n\"; }};Test Create(){ return Test();}int main(){ auto n = Create();} 上边的调用中，为了存储 Create 的返回值，你可能会假设用到了一次临时的复制。C++14 里，大多数编译器都能注意到这个临时对象很容易被优化掉，n 可以从 Create() 中“直接”创建。你很可能会得到如下输出： 12Test::Test // 创建 n~Test // main 结束时销毁 n 这种复制消除的优化行为，依照其基本形式，被叫做返回值优化（Return Value Optimisation——RVO）。 作为实验，你可以在 GCC 里添加编译选项 -fno-elide-constructors 和 -std=c++14（或者其它更早的语言标准）。这时你会看到不同的输出结果： 1234567// compiled as &quot;g++ CopyElision.cpp -std=c++14 -fno-elide-constructors&quot;Test::TestTest(Test&amp;&amp;)~TestTest(Test&amp;&amp;)~Test~Test 这种情况下，编译器用了 2 次额外的复制把返回值传递到 n。 编译器甚至能更聪明，它可以在你返回一个命名对象的情况下进行消除——即所谓的命名返回值优化（Named Return Value Optimisation——NRVO）: 12345678Test Create(){ Test t; // 这里对 t 进行初始化 return t;}auto n = Create(); // 临时对象通常能被消除（译注：t 怎么就变成临时对象了呢？） 当前（译注：指 C++17 之前），标准允许以下情况下的消除： 临时对象被用于初始化另一个对象（包括函数返回的对象、通过 throw 表达式创建的异常对象）时 当一个即将超出范围的变量被返回或抛出时 异常被按值捕获时 但是，消除与否取决于编译器实现。现实是所有的构造函数（译注：即构造、拷贝构造、移动构造）都是必要的。有时候消除只会在 release 构建（优化过的）时发生，debug 构建（没有任何优化选项）不会消除任何东西。 C++17 里，对何时应进行消除有了清楚的规则，甚至构造函数也可能被完全省略。 这样有什么作用呢？ 允许返回不可移动/不可复制的对象——因为现在可以跳过拷贝/移动构造 提升代码可移植性——因为每一个合规的编译器都支持同样的规则 支持按值返回样式而不是使用输出参数 提升性能 下边是一个不可移动/不可复制的类型的例子： 1234567891011121314151617181920212223242526// Chapter Clarification/copy_elision_non_moveable.cpp#include &lt;array&gt;// based on P0135R0struct NonMoveable{ NonMoveable(int x) : v(x) { } NonMoveable(const NonMoveable&amp;) = delete; NonMoveable(NonMoveable&amp;&amp;) = delete; std::array&lt;int, 1024&gt; arr; int v;};NonMoveable make(int val){ if (val &gt; 0) return NonMoveable(val); return NonMoveable(-val);}int main(){ auto largeNonMoveableObj = make(90); // construct the object return largeNonMoveableObj.v;} C++14 里上边的代码会编译失败，因为它缺少拷贝、移动构造函数。但是在 C++17 里这些构造函数不再是必要的了——因为对象 largeNonMoveableObj 会被原地构造。 注意，你可以在函数内使用多个返回语句，复制消除一样可以生效。 此外，重要的是要记住，C++17 的复制消除只对临时对象起作用，对 NRVO 无效。 这种强制性的复制消除在标准里是怎么定义的呢？此功能基于值类别（Value Categories），请继续阅读下一节内容以理解其工作原理。 2.2.1 更新后的值类别C++98/03 里只有两种基本的表达式类别： lvalue rvalue 译注：即左值和右值。 C++11 起这种分类被扩展了（因为有了移动语义），现在有五种类别： lvalue glvalue（泛左值） xvalue（亡值、将亡值） rvalue prvalue（纯右值） 这里有个图表，可以更好地一览所有分类： 请记住，我们有三种核心类别（下边是口语化的“定义”）: lvalue ——有标识符的表达式，且可以取地址 xvalue ——“即将过期（eXpiring）的 lvalue”——可以移动、可以重复使用的对象，通常其生命周期马上结束 prvalue ——（pure rvalue）——没有名字、不能被取地址、可以移动的表达式 译注：C++17 中 prvalue 已经是不可移动了。 为了支持标准化的复制消除，提案作者建议简化 glvalue 和 prvalue 的定义： glvalue ——泛化的 lvalue —— glvalue 是其求值确定一个对象、位域或函数的位置的表达式 译注：原文：“glvalue - “generalised” lvalue - A glvalue is an expression whose evaluation computes thelocation of an object, bit-field, or function” prvalue ——纯 rvalue —— prvalue 是其求值初始化某个对象或位域，或计算某个运算符的操作数的值（依它所出现的上下文而定。译注：即虽然看起来同样的表达式，其类别也不同，比如 a[n]、a.m）的表达式 译注：原文：“prvalue - “pure” rvalue - A prvalue is an expression whose evaluation initialises an object,bit-field, or operand of an operator, as specified by the context in which it appears” 比如： 1234class X { int a; };X{10} // 表达式为 prvalueX x; // x 是 lvaluex.a // 表达式为 lvalue (location) 简言之：prvalue 执行初始化，glvalue 描述位置。 C++17 规定，当你从某个类或数组的 prvalue 对象进行初始化时，不需要创建临时对象。没有任何移动或拷贝牵涉其中（所以也就不需要必须有拷贝或移动构造函数了）；编译器可以安全地进行消除。 它会发生在如下情况： 从一个 prvalue 类别的对象初始化：Type t = T() 一个返回 prvalue 的函数的调用时——跟上边几个例子一样。 有几个例外情况，临时对象仍然是必需的： prvalue 被绑定到某个引用 在一个 prvalue 类别的类对象上执行成员访问 在一个 prvalue 类别的数组上执行下标操作 一个 prvalue 类别的数组被退化到指针 在一个 prvalue 类别的类对象上进行子类到基类的类型转换 prvalue 被用作舍弃的值表达式 扩展：本修改提案：P0135R0 （论证）和 P0135R1（措辞）。 译注： 翻译这节要了老命了！ 又一标准委员会过于学院气的铁证。为了支撑新的语法、新的特性，常常无端构造出一些形而上学的概念，从最初的左值、右值的推出即有此意。 到 C++11，已经彻底不说人话了，用词晦涩难懂，又无法通过 traits 验证结果（仅有 is_lvalue_reference、is_rvalue_reference 几个相关的 traits）。 C++17 更是变本加厉。可以看上述两个提案，简单地说，C++17 通过对五种类别的定义措辞做了所谓的“微调”（tweak），支撑了 Copy Elision 的标准化。这不像是语言设计，更像是某种不可言传、神乎其神的内功心法。 徒耗标准委员会的时间外，这种毫无表征的东西的存在，势必会导致语言理解的复杂度。我们常说要少写注释，让代码清晰到可以自我解释。语言的设计更应该如此，任何复杂特性的用法，都应该通过若干简单、清晰、可具体实施的语法组合实现，绝非通过这种架空的、哲学态的、虚无的定义实现。 回到本节内容本身。值类别前的一小节应该算是易懂的，不做赘述。值类别的更详细、更准确的表述和翻译，可以直接参考这里 和这里 。请恕我才疏学浅。","link":"/C++17%E8%AF%A6%E8%A7%A36.html"},{"title":"C++17 详解 7","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 2.3 过对齐数据的动态内存分配 当你用到 SIMD（Single Instruction，Multiple Data。单指令，多数据），或者有一些其它内存布局的要求时，你可能会需要特别地对齐数据。比如，SSE（Streaming SIMD Extensions）里你需要 16 字节对齐（AVX 256 里是 32 字节对齐要求）。你可以这样定义一个 vec4： 12345class alignas(16) vec4{ float x, y, z, w;};auto pVectors = new vec4[1000]; 注：alignas 指示符在 C++11 引入。 译注：SSE 里数据对齐是必需的；到 AVX，数据对齐已经不是必要条件了，不过会损失部分性能。通常为适配不同硬件平台，可以不做对齐。 但是，C++11/14 没有保证内存是如何对齐的（译注：指动态分配的内存）。通常你不得不使用一些特殊的例程，比如 _aligned_malloc/_aligned_free 来确保维持对齐。这样做也不完美，因为它不能同 C++ 的智能指针一起工作，必须在代码里显式地做内存管理。 C++17 通过引入使用了对齐参数的几个额外的内存分配函数修复了这个漏洞： 123456void* operator new(size_t, align_val_t);void* operator new[](size_t, align_val_t);void operator delete(void*, align_val_t);void operator delete[](void*, align_val_t);void operator delete(void*, size_t, align_val_t);void operator delete[](void*, size_t, align_val_t); 现在，你可以这样分配一个 vec4 数组： 1auto pVectors = new vec4[1000]; 代码没有变化，但是 vec4 的对齐已经被正确地处理了： 1operator new[](sizeof(vec4), align_val_t(alignof(vec4))) 换句话说，new 现在知道对象的对齐方式了。 扩展：本修改提案：P0035R4。 2.4 异常规范作为类型系统的一部分函数的异常规范在过去不属于函数类型的一部分，现在是了。 现在你可以有两个重载的函数：一个带 noexcept，一个不带。 比如，下边的用例会导致编译错误： 1234void (*p)();void (**pp)() noexcept = &amp;p; // error: cannot convert to pointer to noexcept functionstruct S { typedef void (*p)(); operator p(); };void (*q)() noexcept = S(); // error: cannot convert to pointer to noexcept 添加此特性的原因之一，是允许做更进一步优化的可能性。当你保证一个函数是 noexcept 的，且它没有抛出任何异常时，优化就会产生。 译注：noexcept 不具有强制性，一个声明为 noexcept 的函数仍然可以 throw。 另外，如上一章关于 语言修复 中描述，C++17 中的异常规范已经删除了已弃用的异常声明方式。事实上现在你只能通过使用 noexcept 指示符来声明一个函数可能会抛出异常。 扩展：本修改提案：P0012R1。 2.5 编译器支持略。","link":"/C++17%E8%AF%A6%E8%A7%A37.html"},{"title":"C++17 详解 8","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 3 通用语言特性完成了语言修复和阐明的章节后，现在我们准备好浏览其它广泛传播的特性了。本章中描述的改进也有可能使你的代码更加紧凑和富有表现力。 比如，通过结构化绑定，你可以通过更简单的语法使用元组（和类似元组的表达式）。这种在像 Python 这样的其它语言中很容易的东西，现在也可以在 C++ 里实现了！ 本章你将学到： 结构化绑定/分解式声明（译注：原文为 decomposition declaration） 如何为你的自定义类提供结构化绑定接口 带初始化语句的 if/switch 内联变量及其对 header-only 库的影响 lambda 表达式可应用于 constexpr 上下文 嵌套命名空间的简化用法 3.1 结构化绑定声明你经常用到 tuple 或是 pair 吗？ 如果没有，你可能要开始了解这两种轻巧易用的类型了。tuple 能让你捆绑具有良好库支持的临时数据，而不用为所有内容创建自己的类型或使用传出参数。像结构化绑定这样的语言支持使它们（译注：相比自定义类型）更易于处理。 假设有一个返回由两个结果组成的 pair 的函数: 1std::pair&lt;int, bool&gt; InsertElement(int el) { ... } 你可以通过 auto ret = InsertElement(...) 然后引用 ret.first 或 ret.second 的方式使用。或者你可以利用 std::tie，它可以把 tuple/pair 解包到自定义变量： 123int index { 0 };bool flag { false };std::tie(index, flag) = InsertElement(10); 上边的代码可能在你使用 std::set::insert 返回 std::pair 时有用： 12345678std::set&lt;int&gt; mySet;std::set&lt;int&gt;::iterator iter;bool inserted;std::tie(iter, inserted) = mySet.insert(10);if (inserted) std::cout &lt;&lt; \"Value was inserted\\n\"; C++17 里，上边的代码可以变得更紧凑： 123std::set&lt;int&gt; mySet;auto [iter, inserted] = mySet.insert(10); 现在，不需要 pair.first 和 pair.second 了，你可以使用有具体名字的两个变量代替。而且你还只用了一行代码而不是三行，这样更易读了。代码也更安全了，因为 iter 和 inserted 是通过表达式初始化的。 上边这种语法被叫做结构化绑定表达式（structured binding expression）。 3.1.1 语法基本语法如下： 123auto [a, b, c, ...] = expression;auto [a, b, c, ...] { expression };auto [a, b, c, ...] ( expression ); 编译器将 a, b, c, ... 列表中的所有标识符作为所在作用域内的变量名，并将它们绑定到表达式所指代对象的子对象或元素上。 在幕后，编译器可能生成如下伪代码： 1234auto tempTuple = expression;using a = tempTuple.first;using b = tempTuple.second;using c = tempTuple.third; 译注：注意，a b c 的声明方式均是 using。相比 auto a = tempTuple.first; 这种重新定义行为，少了一次拷贝操作，且少占用了一个 a 类型尺寸大小的内存。很精妙！ 概念上来说，表达式结果被拷贝到一个类 tuple 对象（tempTuple）里，其成员变量通过 a, b, c 暴露。但是，变量 a, b, c 不是引用，它们是隐含对象（译注：即临时对象 tempTuple）的成员变量的别名（或绑定）。此临时对象会由编译器分配一个唯一名字。 比如： 12std::pair a(0, 1.0f);auto [x, y] = a; x 绑定了一个 int 对象，其值存储于 a 的一个隐含的拷贝对象中。同理，y 绑定到 float 对象。 修饰符 多种修饰符都可以用在结构化绑定里： const： 1const auto [a, b, c, ...] = expression; 引用： 12auto&amp; [a, b, c, ...] = expression;auto&amp;&amp; [a, b, c, ...] = expression; 比如： 1234std::pair a(0, 1.0f);auto&amp; [x, y] = a;x = 10; // 写访问//a.first 现在等于 10 上边的例子里，x 绑定到了 a 的一个隐含的引用对象的元素上。 同样，现在也很容易获得一个 tuple 成员的引用： 1auto&amp; [ refA, refB, refC, refD ] = myTuple; [[attribute]] 同样适用： 1[[maybe_unused]] auto&amp; [a, b, c, ...] = expression; 译注：[[maybe_unused]] 这个就是标准化的属性，后边有专门的章节介绍。 结构化绑定还是分解式声明？ 对本特性，你可能听过另一个名字——分解式声明（译注：原文为 decomposition declaration）。标准化过程中这两个名字都有考虑过，最终采用了结构化绑定的版本。 结构化绑定不能被声明为 constexpr 有一个限制值得被记住。 1constexpr auto [x, y] = std::pair(0, 0); 这会导致错误： 1error: structured binding declaration cannot be 'constexpr' 此限制有可能在 C++20 通过提案 P1481 被解决。 3.1.2 绑定结构化绑定不只限于 tuple 类型，有三种情况下也可以从中进行绑定： 如果初始值是一个数组： 123// works with arrays:double myArray[3] = { 1.0, 2.0, 3.0 };auto [a, b, c] = myArray; 这种情况下数组被拷贝到一个临时对象，a b c 分别指向临时对象的元素。 标识符个数必须同数组元素数量相等。 如果初始值支持 std::tuple_size&lt;&gt;，并且提供了 get&lt;N&gt;() 和 std::tuple_element 函数： 12std::pair myPair(0, 1.0f);auto [a, b] = myPair; // 绑定 myPair.first/second 上边的片段里我们绑定了 myPair。这意味着你同样可以为你自己的类提供结构化绑定服务，前提是你添加了 get&lt;N&gt; 接口实现。参考稍后小节里的例子。 如果初始值类型只包含非静态、公有成员： 12345678910struct Point { double x; double y;};Point GetStartPoint() { return { 0.0, 0.0 };}const auto [x, y] = GetStartPoint(); x 和 y 分别指向 Point 结构体中的 Point::a 和 Point::b。 自定义类不必是 POD（译注：Plain Old Data），但是标识符的数量必须等于非静态数据成员的数量。 注：C++17 里，你可以通过结构化绑定来绑定类的成员，只要它们是公有的。但当你想（通过结构化绑定）访问类的私有成员时就有问题了。C++20 里此问题得到了修复。参考 P0969R0。 3.1.3 示例最酷的用例之一——在 range based for 循环里绑定： 12345std::map&lt;KeyType, ValueType&gt; myMap;for (const auto &amp; [key,val] : myMap){ // 使用 key/value 而不是 iter.first/iter.second} 上边的例子里，我们绑定到了 [key, val] 键值对，从而可以在循环体中使用这些变量名称。在 C++17 之前，你必须操作 map 的迭代器——即一个 pair&lt;first, second&gt;。使用 key/value 的实际名字让代码变得更有表现力。 上述技巧可以被用于： 123456789101112131415#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;string&gt;int main(){ const std::map&lt;std::string, int&gt; mapCityPopulation { { \"Beijing\", 21'707'000 }, { \"London\", 8'787'892 }, { \"New York\", 8'622'698 } }; for (auto&amp;[city, population] : mapCityPopulation) std::cout &lt;&lt; city &lt;&lt; \": \" &lt;&lt; population &lt;&lt; '\\n';} 循环体内，你可以安全地使用变量 city 和 population。 为自定义类提供结构化绑定接口 如之前提到的，你可以为自定义类提供结构化绑定支持。 为此，你必须定义对应类型的 get&lt;N&gt;，std::tuple_size 和 std::tuple_element 的特化版本。 比如，如果你有一个有三个成员的类，但是你只想暴露其公有接口： 1234567891011class UserEntry {public: void Load() { } std::string GetName() const { return name; } unsigned GetAge() const { return age; }private: std::string name; unsigned age { 0 }; size_t cacheEntry { 0 }; // 不暴露}; 结构化绑定需要的接口： 123456789101112// 利用 if constexpr:template &lt;size_t I&gt; auto get(const UserEntry&amp; u) { if constexpr (I == 0) return u.GetName(); else if constexpr (I == 1) return u.GetAge();}namespace std { template &lt;&gt; struct tuple_size&lt;UserEntry&gt; : std::integral_constant&lt;size_t, 2&gt; { }; template &lt;&gt; struct tuple_element&lt;0,UserEntry&gt; { using type = std::string; }; template &lt;&gt; struct tuple_element&lt;1,UserEntry&gt; { using type = unsigned; };} tuple_size 指明可获取的字段的数量，tuple_element 定义了指定元素的类型，get&lt;N&gt; 返回元素的值。 或者你可以显式地特化 get&lt;&gt; 代替 if constexpr： 12template&lt;&gt; string get&lt;0&gt;(const UserEntry &amp;u) { return u.GetName(); }template&lt;&gt; unsigned get&lt;1&gt;(const UserEntry &amp;u) { return u.GetAge(); } 对很多类型，写两个（或多个）函数可能比 if constexpr 版本更简单。 译注：也更合理，符合单一职责原则和开闭原则。 现在，你可以通过结构化绑定使用 UserEntry 了，比如： 1234UserEntry u;u.Load();auto [name, age] = u; // 读访问std:: cout &lt;&lt; name &lt;&lt; \", \" &lt;&lt; age &lt;&lt; '\\n'; 本例只允许对类的读访问。如果你想要写入，类应该提供返回成员引用的访问函数，然后你要修改 get 的实现以支持引用。 如你所见，我们用到了 if constexpr 来实现 get&lt;N&gt;，后边有对 if constexpr 介绍的章节。 扩展：本修改提案：P0217（措辞），P0144（论证和示例），P0615（“分解式声明”改名为“结构化绑定”）。","link":"/C++17%E8%AF%A6%E8%A7%A38.html"},{"title":"C++17 详解 9","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 3.2 带初始化语句的 if 和 switchC++17 提供了新版本的 if 和 switch 语句： if (init; condition) 和 switch (init; condition)。 在 init 分区你可以定义一个新变量，然后在 condition 分区校验它。此变量只在 if/else 作用域内可见。 要达到相似的效果，C++17 之前你必须这么写： 1234567{ auto val = GetValue(); if (condition(val)) // 条件为真 else // 条件为假...} 请注意，val 在一个独立的作用域内（译注：最外层的一对大括号），如果没有它变量会“泄漏”到封闭作用域。 现在，C++17 里，你可以这么写： 1234if (auto val = GetValue(); condition(val)) // 条件为真else // 条件为假... val 只在 if 和 else 语句内可见，所以它不会“泄漏”。condition 可以是任意 bool 条件。 这样做有什么用呢？ 假设你想要在字符串里进行一些查找： 123456789const std::string myString = \"My Hello World Wow\";const auto pos = myString.find(\"Hello\");if (pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" Hello\\n\"; const auto pos2 = myString.find(\"World\");if (pos2 != std::string::npos) std::cout &lt;&lt; pos2 &lt;&lt; \" World\\n\"; 你不得不为（两次） pos 使用不同的名字，或者用一个独立的作用域封闭起来： 12345678910{ const auto pos = myString.find(\"Hello\"); if (pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" Hello\\n\";}{ const auto pos = myString.find(\"World\"); if (pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" World\\n\";} 新的 if 语句可以只用一行生成额外的作用域： 12345if (const auto pos = myString.find(\"Hello\"); pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" Hello\\n\"; if (const auto pos = myString.find(\"World\"); pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" World\\n\"; 如前所述，if 中定义的变量在 else 块内同样可见。所以下边的写法也没问题： 1234if (const auto pos = myString.find(\"World\"); pos != std::string::npos) std::cout &lt;&lt; pos &lt;&lt; \" World\\n\";else std::cout &lt;&lt; pos &lt;&lt; \" not found!!\\n\"; 另外，你可以利用结构化绑定（摘自 Herb Sutter 代码）： 12345// 更好的结合: 结构化绑定 + if 初始值if (auto [iter, succeeded] = mymap.insert(value); succeeded) {use(iter); // ok// ...} // iter 和 succeeded 在这里销毁 扩展：本修改提案：P0305R1。 3.3 内联变量随着 C++11 非静态成员变量初始化的引入，现在你可以在声明成员变量的同时进行初始化： 12345class User{ int _age {0}; std::string _name {\"unknown\"};}; 对静态变量（或常量静态）你通常仍然需要在 cpp 文件里进行定义。 C++11 和 constexpr 关键字允许你在同一个地方声明并定义静态变量，但是仅限于常量表达式。 在此之前，只有函数可以被指定为 inline，现在你可以对变量做同样的事了——在头文件里。 摘自提案 P0385R2：内联变量同内联函数具有相同的语义：它可以在多个编译单元内被一模一样地定义多次，必须在每一个用到的编译单元内定义（译注：即可见），程序行为如同它们是同一个变量一样。 译注：上边的引用说明了两件事： 内联变量的可见性规则。其实是跟内联函数一模一样的——如你在头文件中定义，只需包含此头文件，变量即对所在编译单元可见；如在源文件中定义，需要在所有用到的源文件中分别定义，且要保证定义形式一致。 每个编译单元内都有一份变量的定义——不管是你显式定义或是编译器生成的。所以，每个变量都只是如同（原文为 as if）一个变量，而不是真正意义上的一个变量。我在 VS2019 下验证过，不管是头文件中定义后包含，或者每个源文件中分别定义，各个编译单元内打印出的内联变量的地址都是不同的。 比如： 12345678// inside a header file:struct MyClass{ static const int sValue;};// later in the same header file:inline int const MyClass::sValue = 777; 或者甚至在同一个地方声明和定义： 1234struct MyClass{ inline static const int sValue = 777;}; 注意，constexpr 变量是隐式内联的，所以没必要写 constexpr inline myVal = 10;。 内联变量比 constexpr 变量更灵活，因为它不必必须用一个常量表达式初始化。比如，你可以用 rand() 初始化一个内联变量，constexpr 则不行。 内联变量怎么做到简化代码的呢？ A lot of header-only libraries can limit the number of hacks(like using inline functions or templates)and switch to using inline variables. 译注：不知所云，不敢译…… 比如： 123456789class MyClass{ static inline int Seed(); // static method};inline int MyClass::Seed() { static const int seed = rand(); return seed;} 可以被改为： 1234class MyClass{ static inline int seed = rand();}; C++17 保证 MyClass::seed 在所有编译单元内具有相同值（运行时生成）！ 扩展：本修改提案：P0386R2。","link":"/C++17%E8%AF%A6%E8%A7%A39.html"},{"title":"C++17 详解 10","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 3.4 constexpr lambda 表达式lambda 表达式自 C++11 引入后，就成为了现代 C++ 必不可少的一部分。C++11 的另一个重要特性是“常量表达式”——主要通过 constexpr 声明。C++17 允许这两个元素共存——你可以在一个常量表达式上下文中调用 lambda 。 C++11/14 里，下边的代码不能通过编译： 12auto SimpleLambda = [] (int n) { return n; };static_assert(SimpleLambda(3) == 3, \"\"); 以 -std=c++11 flag 在 GCC 下编译会报如下错误： 12error: call to non-'constexpr' function 'main()::&lt;lambda(int)&gt;'static_assert(SimpleLambda(3) == 3, \"\"); 但是，换成 -std=c++17 代码就可以编译通过了！这是因为 C++17 里遵循标准 constexpr 函数规则的 lambda 表达式被隐式地声明为了 constexpr。 这句话什么意思呢？有什么限制呢？ 摘自 Standard - 10.1.5 constexpr 指示符 [dcl.constexpr] 译注：完整版的 C++17 标准草案发布在这里——有 1622 页。 一个被定义为 constexpr 的函数应满足如下条件： 不能是虚函数（13.3）； 返回类型应是一个字面类型（译注：原文为 literal type，不是字面值的意思，标准里有明确的、复杂的定义。）； 每一个参数的类型均应是字面类型； 函数体应是 = delete 或 = default，或是一个不包含如下内容的复合语句： 汇编实现， goto 语句， 标识符标签（译注：即同 goto 配合使用的 val:）， try 块， 非字面类型的，或静态的，或线程存储周期（译注：即 thread_local）的，或未进行初始化的变量的定义。 译注：如我之前吐槽，C++ 的一大精通难点体现在，一个小小的特性关键字背后，是嵌套了 N 层的、晦涩的、没有任何表征的概念定义。constexpr 可见一斑。 实践角度讲，如果想要你的函数或 lambda 在编译期被执行，函数体内不应调用任何非 constexpr 代码。比如，不能动态分配内存。 lambda 也可以显式地声明为 constexpr： 1auto SimpleLambda = [] (int n) constexpr { return n; }; 如果你违反了 constexpr 函数规则，会触发编译错误。 12345auto FaultyLeakyLambda = [] (int n) constexpr { int *p = new int(10); return n + (*p);}; new 操作符是非 constexpr 的所以上边代码不会编译通过。 constexpr lambda 在结合了即将到来的 C++20 的 constexpr 标准算法后将会是一个伟大特性。 扩展：本修改提案：P0170。 3.5 嵌套命名空间命名空间允许把类型和函数分组到不同的逻辑单元。 比如，通常会把一个叫 XY 库里的类型和函数存储到一个叫 xy 的命名空间。如下所示，有一个 SuperCompressionLib 命名空间，它暴露了两个叫 Compress 和 Decompress 的函数： 1234namespace SuperCompressionLib { bool Compress(); bool Decompress();} 如果你有两层或更多嵌套的命名空间，事情就变得有趣了。 123456789101112namespace MySuperCompany { namespace SecretProject { namespace SafetySystem { class SuperArmor { // ... }; class SuperShield { // ... }; } // SafetySystem } // SecretProject} // MySuperCompany C++17 里，嵌套命名空间可以以一种更紧凑的方式书写： 12345678namespace MySuperCompany::SecretProject::SafetySystem { class SuperArmor { // ... }; class SuperShield { // ... };} 这种语法令人愉悦，对有 C# 或 Java 经验的开发者也更容易使用。 C++17 里，标准库的许多地方也以这种新的嵌套命名空间特性被“压缩了”： 比如 regex 库。 C++17 里它的定义如下： 1234namespace std::regex_constants { typedef T1 syntax_option_type; // ...} C++17 之前同样的代码被声明为： 123456namespace std { namespace regex_constants { typedef T1 syntax_option_type; // ... }} 上边的嵌套声明出现在 C++ 规范，但每一个 STL 实现可能都会不同。 扩展：本修改提案：P4230。 3.6 编译器支持略。","link":"/C++17%E8%AF%A6%E8%A7%A310.html"},{"title":"C++17 详解 11","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 4. 模版你是否用过模版或元编程？ 如果你的回答是“是”，那你可能会对本次 C++17 的更新感到非常开心。 新标准引入了许多使模版编程更简单更富有表现力的加强措施。 本章你将学到： 类模板的模版参数推断 template&lt;auto&gt; 折叠表达式 if constexpr ——编译时 if！ 其它一些小的、细致的改进和修复 4.1 类模板的模版参数推断你经常用 make_Type 函数构建模版对象（比如 std::make_pair）吗？ 通过 C++17 你可以把它们忘掉然后只使用一个普通形式的构造函数了。C++17 填补了一个模版推断规则的缺口。现在模版推断对类模版也会触发，而不只是对函数。这也意味着你的许多代码——那些 make_Type 函数现在可以被删掉了。 举例来说，为了创建一个 pair，以前这么写会更方便： 1auto myPair = std::make_pair(42, \"hello world\"); 而不是： 1std::pair&lt;int, std::string&gt; myPair(42, \"hello world\"); 因为 std::make_pair 是一个模版函数，编译器可以对函数的模版参数执行自动推断，所以没必要这么写： 1auto myPair = std::make_pair&lt;int, std::string&gt;(42, \"hello world\"); 现在，C++17 起，合规的编译器可以很好地推断类模版的模版参数类型了。 在我们的例子里，现在你可以这么写： 12using namespace std::string_literals;std::pair myPair(42, \"hello world\"s); // 自动推断! 这可以大大地削减下边这样的复杂的构造过程： 123456// lock guard:std::shared_timed_mutex mut;std::lock_guard&lt;std::shared_timed_mutex&gt; lck(mut);// array:std::array&lt;int, 3&gt; arr {1, 2, 3}; 现在可以变成这样： 1234std::shared_timed_mutex mut;std::lock_guard lck(mut);std::array arr { 1, 2, 3 }; 注意，部分推断不会发生，你必须全部写明所有的模版参数或全部不写： 123std::tuple t(1, 2, 3); // OK: 推断std::tuple&lt;int,int,int&gt; t(1, 2, 3); // OK: 所有参数类型都提供了std::tuple&lt;int&gt; t(1, 2, 3); // Error: 部分推断 有了这个特性，许多 make_Type 函数可能都不需要了——尤其那些“模拟”类的模版推断的函数。 但是仍然有一些工厂函数做了额外的工作。比如 std::make_shared ——它不只创建了 shared_ptr，同时确保了控制块（译注：指引用计数的控制块）和所指向对象在一个内存区域内被分配： 12345// 控制块和 int 对象可能在内存的不同地方std::shared_ptr&lt;int&gt; p(new int{10});// 控制块和 int 对象在连续内存区域auto p2 = std::make_shared&lt;int&gt;(10); 译注：std::shared_ptr 和 std::make_shared 的实现细节是我特别喜欢面试的一个知识点。 类的模版参数推断是怎么工作的呢？ 让我们进入“推断指引”部分。 推断指引 编译器使用名叫“推断指引”（deduction guides）的特殊规则计算模版类的类型。 这些规则又分两类：编译器生成的（隐式生成）和用户自定义的。 为了理解编译器如何使用这些指引，让我们看一个例子。 这里是一个对 std::array 的自定义推断指引： 12template &lt;class T, class... U&gt;array(T, U...) -&gt; array&lt;T, 1 + sizeof...(U)&gt;; 语法看起来像一个带尾随返回类型的模版函数。编译器视这种“虚拟的”函数为参数推断的一个候补。如果样式匹配，本次推断就返回恰当的类型。 在我们的案例里当你写下： 1std::array arr {1, 2, 3, 4}; 时，即假设 T 和 U... 都是同一类型，我们可以构建一个 std::array&lt;int, 4&gt; 类型的数组对象。 大多数情况下，你可以依赖编译器自动生成（译注：隐式的）推断指引。它们会对基本的类模版的每一个构造函数（包括拷贝/移动构造）创建。请注意，对特化或偏特化类不生效。 刚才说过，你也可以定义自己的推断指引： 需要添加自定义推断指引的一个经典例子是 std::string 取代 const char * 的推断： 12345678910template&lt;typename T&gt;struct MyType{ T str;};// 自定义推断指引MyType(const char *) -&gt; MyType&lt;std::string&gt;;MyType t{\"Hello World\"}; 没有自定义推断指引的的话 T 会被推断为 const char *。 另一个自定义推断指引的例子是 overload： 12345template&lt;class... Ts&gt;struct overload : Ts... { using Ts::operator()...; };template&lt;class... Ts&gt;overload(Ts...) -&gt; overload&lt;Ts...&gt;; // 推断指引 overload 类继承自 Ts... 几个类，然后把它们的 operator() 暴露出去。在这里自定义推断指引被用来把一组 lambda “转换”成一组可以继承的类。 译注：lambda 本质上是一个匿名函数对象，即重写了 operator() 的类，所以 using Ts::operator()... 才可能成立。 译注：这里的 overload，不是我们认知的面向对象领域的“重载”，是一种泛化了的用到了重载的惯用手法。其表现形式就是上边代码中展示的样子，通常的应用场景是配合 std::visit 实现对 std::variant 中所有类型的访问。可以参考这里。本书后边也有类似的应用案例，并配有比较详细的解释。 扩展：本修改提案：P0091R3 和 P0433——标准库中的推断指引。 请注意：尽管编译器可能声明了已经完全支持类模板的模板参数推断，其对应的 STL 实现可能还是缺少对某些 STL 类型的自定义推断指引。参考本章最后的编译器支持章节。（译注：编译器支持这东西时效性太短，我不会翻译原文，也不会带一份本文译写时最新的支持列表，请自行查阅。）","link":"/C++17%E8%AF%A6%E8%A7%A311.html"},{"title":"Windows 下 Qt Installer Framework 源码编译","text":"三个大步骤： Qt 源码静态编译 配置静态库 Qt Installer Framework 源码编译 1. Qt 静态编译通过安装器安装的 Qt ，只有动态链接库版本，不适用于 Qt Installer Framework 的编译。需要自己从源码构建出静态库。 以下步骤完全参考 Qt Wiki，英文过关的可以直接阅读原文。 1.1 编译环境 Windows 10 Windows PowerShell（默认随系统安装） Qt 5.15.2 MinGW 8.1.0 64-bit（安装器有对应选项） 下载安装 7-zip Perl 5.12+ (http://www.activestate.com/activeperl/) Python 2.7+ (http://www.activestate.com/activepython/) Ruby 1.9.3+ (http://rubyinstaller.org/) 1.2 下载并修改 PowerShell 脚本 下载 qt-windows10-static-build.ps1 这个 PowerShell 脚本，具体的构建过程全在脚本里。 1.2.1 打开脚本文件，并定位到 1$QtStaticDir = &quot;C:\\Qt\\Static&quot;, # NO TRAILING SLASH 所在行。此变量表示编译输出目录，改成你的自定义目录。 1.2.2 定位到 1$GccList = @(Get-ChildItem -Path C:\\Qt\\Tools\\mingw*\\bin\\gcc.exe 所在行，将 Path 值改为你的 Qt 安装目录下的相应路径。 1.2.3 定位到 1cmd /c &quot;configure.bat 所在行： 将 -skip qtdeclarative 选项删掉，Qt Installer Framework 依赖 Qml 库； 在 -qt-webp 选项后边添加 -qt-tiff 选项，Qt Installer Framework 同样依赖 tiff 图片格式库。 1.3 编译 右键 PowerShell 脚本，弹出菜单里选择 “使用 PowerShell 运行”，编译开始。 耗时较长（数小时计），耐心等待。 编译完成后，在自定义的输出目录下会出现一个 $QT_VERSION 命名的文件夹，在 $QT_VERSION\\lib 目录下可以看到所有的 .a 文件。 2. Qt Creator 配置 Qt 静态库。 以下步骤完全参考 Qt Wiki，英文过关的可以直接阅读原文。 打开 Qt Creator 工具菜单-&gt;选项 选中左边 Kits 选项页，选择 Qt Versions 标签页。 点击添加按钮，选中上一步编译出的 qmake.exe 文件，即 $QT_VERSION\\bin\\qmake.exe。可以看到 Manual 树下多了一行，可以选中它，给它取一个更有识别度的版本名称，比如 Qt %{Qt:Version} MinGW Static 64bit。 点击应用按钮。 选择 Kits 标签页。 Manual 树下应该会自动添加一行，对应上边步骤的 Qt 版本（如果没有自动添加，可以点击 Add 按钮，选中新行，点击下边列表的名称一行右边图标，下拉菜单里选择上一步骤 Qt 版本，完成手动添加。）。 修改列表中 Compiler 一栏，将 C/C++ 编译器分别改为 MinGW 8.1.0 64-bit for C、MinGW 8.1.0 64-bit for C++。 3. Qt Creator 中编译 Qt Installer Framework下载 QtIFW 源码：https://github.com/LiangZuoting/installer-framework.git Qt Creator 中通过源码根目录下 installerfw.pro 文件打开工程。 打开 installerbase.rc 文件，将 13 行 1VALUE &quot;FileVersion&quot;, IFW_VERSION_STR_WIN32 改为 1VALUE &quot;FileVersion&quot;, &quot;4.0.1&quot; 具体的版本号依你自己情况而定，且要记得更新版本号时同步修改此处。 这是一个已知 BUG，一直没有修复。 然后就可以编译了。数分钟后，在 QtIFW 源码根目录下会多一个 bin 目录，里边是输出文件。 参考 Building a static Qt for Windows using MinGW: https://wiki.qt.io/Building_a_static_Qt_for_Windows_using_MinGW","link":"/Windows-%E4%B8%8B-Qt-Installer-Framework-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91.html"},{"title":"C++17 详解 12","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 4.2 折叠表达式C++11 引入了可变参模版，这是一个非常强力的特性，特别是你想实现一个有可变数量的模版参数的函数时。比如，（C++11）之前你不得不实现多个不同版本的模版函数（一个带一个参数、另一个带两个参数、另一个带三个参数……）。 当你想实现类似 sum 这样的递归函数时，可变参模版仍然需要一些额外的代码。你必须指明递归规则。 比如： 12345678auto SumCpp11(){ return 0;}template&lt;typename T1, typename... T&gt;auto SumCpp11(T1 s, T... ts){ return s + SumCpp11(ts...);} 通过 C++17 我们可以把代码写得更简单: 12345678910template&lt;typename ...Args&gt; auto sum(Args ...args){ return (args + ... + 0);}// 或者甚至:template&lt;typename ...Args&gt; auto sum2(Args ...args){ return (args + ...);} 有如下几种使用二元操作符的折叠表达式的变种： 表达式 名称 解释 (... op e) 一元左折叠 ((e1 op e2) op ...) op eN (init op ... op e) 二元左折叠 (((init op e1) op e2) op ...) op eN (e op ...) 一元右折叠 e1 op (... op (eN-1 op eN)) (e op ... op init) 二元右折叠 e1 op (... op (eN-1 op (eN op init))) 译注：注意，折叠表达式外层必须有一个括号。 op 可以是下边 32 种二元操作符中的任意一个：+ - * / % ^ &amp; | = &lt; &gt; &lt;&lt; &gt;&gt; += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || , .* -&gt;* 。在一个二元折叠里，两个 op 必须一样。 比如，当你写下： 123456template&lt;typename ...Args&gt; auto sum2(Args ...args){ return (args + ...); // unary right fold over '+'}auto value = sum2(1, 2, 3, 4); 模版函数被展开为： 1auto value = 1 + (2 + (3 + 4)); 对空参数包，默认得到下列值： 操作符 默认值 &amp;&amp; true || false , void() 其它 错误 这也是为什么你不能不带任何参数调用 sum2，因为 + 操作符上的一元折叠对空参数列表没有任何默认值。 更多示例 这里有一个使用折叠的非常好的 printf 实现 P0036R0： 1234567template&lt;typename ...Args&gt;void FoldPrint(Args&amp;&amp;... args){ (std::cout &lt;&lt; ... &lt;&lt; std::forward&lt;Args&gt;(args)) &lt;&lt; '\\n';}FoldPrint(\"hello\", 10, 20, 30); 但是上边的 FoldPrint 一个接一个地打印参数，没有任何分隔符。所以你会看到 “hello102030” 这样的输出。 如果想要分隔符和其它更多格式化选项，你必须调整打印技巧，在逗号操作符上使用折叠： 12345678template&lt;typename ...Args&gt;void FoldSeparateLine(Args&amp;&amp;... args){ auto separateLine = [](const auto&amp; v) { std::cout &lt;&lt; v &lt;&lt; '\\n'; }; (... , separateLine (std::forward&lt;Args&gt;(args))); // over comma operator} 这种通过逗号操作符使用折叠的技巧很方便。另一个例子是一个 push_back 的特殊版本： 12345678template&lt;typename T, typename... Args&gt;void push_back_vec(std::vector&lt;T&gt;&amp; v, Args&amp;&amp;... args){ (v.push_back(std::forward&lt;Args&gt;(args)), ...);}std::vector&lt;float&gt; vf;push_back_vec(vf, 10.5f, 0.7f, 1.1f, 0.89f); 一般来讲，折叠表达式能让你写出更清晰、更短小、也可能读起来更令人愉悦的代码。 扩展：本修改提案：N4295 和 P0036R0。","link":"/C++17%E8%AF%A6%E8%A7%A312.html"},{"title":"C++17 详解 13","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 4.3 if constexpr这是一个重点！ C++ 的编译时 if！ 此特性可以让你在编译时舍弃基于常量表达式条件的 if 语句的分支。 1234if constexpr (cond) statement1; // cond 为 false 时舍弃else statement2; // cond 为 true 时舍弃 比如： 12345678template &lt;typename T&gt;auto get_value(T t){ if constexpr (std::is_pointer_v&lt;T&gt;) return *t; else return t;} if constexpr 有能力简化许多模版代码——特别是用到标签调度（译注：tag dispatching）、SFINAE 或预处理器技巧时。 译注： 标签调度的示例。 SFINAE 的详细解释。 通俗地讲，都是实现模版特化/重载的技术手段。if constexpr 更轻量，允许在同一函数内使用 if 分支实现编译期条件选择。本文后边有一个这三种技术应用比较的例子。 为什么需要编译时 if ？ 一开始你可能会问，为什么我们需要 if constexpr，还有那些复杂的模版化的表达式？普通的 if 不行吗？ 这里有一段示例代码： 12345678template &lt;typename Concrete, typename... Ts&gt;unique_ptr&lt;Concrete&gt; constructArgs(Ts&amp;&amp;... params){ if (is_constructible_v&lt;Concrete, Ts...&gt;) // 普通 if return make_unique&lt;Concrete&gt;(forward&lt;Ts&gt;(params)...); else return nullptr;} 上述例程是 make_unique 的“更新”版本：当参数允许它构造包装的对象时返回 unique_ptr，否则返回 nullptr。 下边是一份测试 constructArgs 的简单代码： 12345678910class Test{public: Test(int, int) { }};int main(){ auto p = constructArgs&lt;Test&gt;(10, 10, 10); // 3 个参数！} 代码试图用 3 个参数构造 Test，但是请注意 Test 只有一个接受两个 int 实参的构造函数。 编译时会得到类似如下的编译错误： 123456In instantiation of 'typename std::_MakeUniq&lt;_Tp&gt;::__single_object std::make_unique(\\_Args&amp;&amp; ...) [with _Tp = Test; _Args = {int, int, int}; typename std::_MakeUniq&lt;_Tp&gt;\\::__single_object = std::unique_ptr&lt;Test, std::default_delete&lt;Test&gt; &gt;]':main.cpp:8:40: required from 'std::unique_ptr&lt;_Tp&gt; constructArgs(Ts&amp;&amp; ...) [with C\\oncrete = Test; Ts = {int, int, int}]' 让我们试着理解这条错误消息。在模板推断后，编译器编译出如下代码： 1234if (std::is_constructible_v&lt;Concrete, 10, 10, 10&gt;) return std::make_unique&lt;Concrete&gt;(10, 10, 10);else return nullptr; 在运行时 if 分支永远不会被执行——因为 is_constructible_v 返回 false，但是此分支内的代码必须能编译通过。 这就是为什么我们需要 if constexpr，可以“舍弃”代码，只编译匹配的语句。 为了修复上边代码你必须添加 constexpr： 12345678template &lt;typename Concrete, typename... Ts&gt;unique_ptr&lt;Concrete&gt; constructArgs(Ts&amp;&amp;... params){ if constexpr (is_constructible_v&lt;Concrete, Ts...&gt;) // 好了！ return make_unique&lt;Concrete&gt;(forward&lt;Ts&gt;(params)...); else return nullptr;} 现在，编译器在编译时计算出 if constexpr 的值，对 auto p = constructArgs&lt;Test&gt;(10, 10, 10); 这句来说，整个的 if 分支都在编译处理的第二个步骤里被“删除”了。 准确地说，被舍弃分支里的代码不是在编译阶段被完全删除了的。只有那些依赖于条件里用到的模板参数的表达式不会被实例化。但是要求语法上必须是有效的。 比如： 1234567891011121314template &lt;typename T&gt;void Calculate(T t){ if constexpr (is_integral_v&lt;T&gt;) { // ... static_assert(sizeof(int) == 100); } else { execute(t); strange syntax }} 上边的伪代码里，如果 T 的类型是 int，else 分支会被舍弃，意味着 execute(t) 不会被实例化。但是 strange syntax 这行仍然会被编译（因为它不依赖 T），这也是为什么你将会得到一个编译错误的原因。 然后，另一个编译错误从 static_assert 抛出，这个表达式也不依赖 T，所以它也会被（编译器）计算。 模版代码简化 C++17 之前，如果你有一个算法的多个版本——它们是依赖于类型需求的，你可能会通过 SFINAE 或标签调度生成候补重载决议集。 比如： 1234567891011121314// Chapter Templates/sfinae_example.cpptemplate &lt;typename T&gt;std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt; simpleTypeInfo(T t){ std::cout &lt;&lt; \"foo&lt;integral T&gt; \" &lt;&lt; t &lt;&lt; '\\n'; return t;}template &lt;typename T&gt;std::enable_if_t&lt;!std::is_integral_v&lt;T&gt;, T&gt; simpleTypeInfo(T t){ std::cout &lt;&lt; \"not integral \\n\"; return t;} 上边的例子里有两个函数实现，但是只可能有一个会最终进入重载决议集。如果 std::is_integral_v&lt;T&gt; 为真就选择上边的函数，第二个因为 SFINAE 的缘故被拒绝。 同样的事发生在标签调度时： 1234567891011121314151617181920// Chapter Templates/tag_dispatching_example.cpptemplate &lt;typename T&gt;T simpleTypeInfoTagImpl(T t, std::true_type){ std::cout &lt;&lt; \"foo&lt;integral T&gt; \" &lt;&lt; t &lt;&lt; '\\n'; return t;}template &lt;typename T&gt;T simpleTypeInfoTagImpl(T t, std::false_type){ std::cout &lt;&lt; \"not integral \\n\"; return t;}template &lt;typename T&gt;T simpleTypeInfoTag(T t){ return simpleTypeInfoTagImpl(t, std::is_integral&lt;T&gt;{});} 不同于 SFINAE，我们为每一种条件生成一个唯一的标签类型：true_type 或 false_type。基于结果，只有一个实现会被选择。 现在我们可以通过 if constexpr 简化这种模式： 12345678910111213template &lt;typename T&gt;T simpleTypeInfo(T t){ if constexpr (std::is_integral_v&lt;T&gt;) { std::cout &lt;&lt; \"foo&lt;integral T&gt; \" &lt;&lt; t &lt;&lt; '\\n'; } else { std::cout &lt;&lt; \"not integral \\n\"; } return t;} 模版代码的书写变得更“自然”了，而且也不需要那么多“伎俩”（译注：原文为 tricks）了。 示例 让我们看另外两个示例： 行打印 你可能已经在本书开头的快速开始小节看到过下边的示例了。让我们深入细节看看代码是怎么工作的。 123456789101112131415161718192021template&lt;typename T&gt; void linePrinter(const T&amp; x){ if constexpr (std::is_integral_v&lt;T&gt;) { std::cout &lt;&lt; \"num: \" &lt;&lt; x &lt;&lt; '\\n'; } else if constexpr (std::is_floating_point_v&lt;T&gt;) { const auto frac = x - static_cast&lt;long&gt;(x); std::cout &lt;&lt; \"flt: \" &lt;&lt; x &lt;&lt; \", frac \" &lt;&lt; frac &lt;&lt; '\\n'; } else if constexpr(std::is_pointer_v&lt;T&gt;) { std::cout &lt;&lt; \"ptr, \"; linePrinter(*x); } else { std::cout &lt;&lt; x &lt;&lt; '\\n'; }} linePrinter 利用 if constexpr 检查输入类型。基于此我们可以输出额外信息。有意思的是指针类型——当指针被检测到，代码对其解引用然后递归调用 linePrinter。 声明自定义 get&lt;N&gt; 函数 结构化绑定对只有公有成员的简单结构体有效，比如： 123456789struct S{ int n; std::string s; float d;};S s;auto [a, b, c] = s; 但是，如果你有一个带私有成员的自定义类型，那你可能要重载 get&lt;N&gt; 函数以使结构化绑定能生效。看下边演示代码： 1234567891011121314151617181920212223class MyClass{public: int GetA() const { return a; } float GetB() const { return b; }private: int a; float b;};template &lt;std::size_t I&gt; auto get(MyClass&amp; c){ if constexpr (I == 0) return c.GetA(); else if constexpr (I == 1) return c.GetB();}// specialisations to support tuple-like interfacenamespace std{ template &lt;&gt; struct tuple_size&lt;MyClass&gt; : std::integral_constant&lt;size_t, 2&gt; { }; template &lt;&gt; struct tuple_element&lt;0,MyClass&gt; { using type = int; }; template &lt;&gt; struct tuple_element&lt;1,MyClass&gt; { using type = float; };} 上边代码有一个优点：用一个函数完成所有工作。你也可以用模版特化实现： 12template &lt;&gt; auto&amp; get&lt;0&gt;(MyClass &amp;c) { return c.GetA(); }template &lt;&gt; auto&amp; get&lt;1&gt;(MyClass &amp;c) { return c.GetB(); } 在后边“用 if constexpr 替换 std::enable_if” 一章中有更多相关示例，“结构化绑定”一章中也有，在关于自定义 get&lt;N&gt; 特化小节中。 你也可以参考这篇文章：C++17 中使用 if constexpr 简化代码。 扩展：本修改提案：P0292R2。","link":"/C++17%E8%AF%A6%E8%A7%A313.html"},{"title":"C++17 详解 14","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 4.4 用 auto 声明非类型模版参数这是在任何地方使用 auto 策略的另一部分。C++11/14 里你可以利用 auto 自动推断变量甚至返回值的类型，另外还有泛型 lambda。现在你也可以利用它推断非类型模版参数了。 比如： 12template &lt;auto value&gt; void f() { }f&lt;10&gt;(); // 推断为 int 这很实用，因为你不必为指明非类型参数的类型而添加一个独立的参数了。 比如 C++11/14 里： 12template &lt;typename Type, Type value&gt; constexpr Type TConstant = value;constexpr auto const MySuperConst = TConstant&lt;int, 100&gt;; C++17 里代码能稍稍简洁一点： 12template &lt;auto value&gt; constexpr auto TConstant = value;constexpr auto const MySuperConst = TConstant&lt;100&gt;; 不需要再显式地写明 Type 了。 异构编译时链表作为一种进阶用法在大量论文、文章中被引用： 12template &lt;auto ... vs&gt; struct HeterogenousValueList {};using MyList = HeterogenousValueList&lt;'a', 100, 'b'&gt;; C++17 之前是不可能直接声明这样一个链表的，首先必须提供某种封装类。 扩展：本修改提案：P0127R2。在 P0127R1 里有更多示例和讨论。 4.5 其它修改C++17 里还有其它一些跟模版相关的语言特性值得一提： 允许在模版的模版参数中使用 typename 译注：模版的模版参数（template template parameters），参数为模版的模版。 声明模版的模版参数时允许使用 typename 代替 class 关键字。普通类型参数可以互换使用两者，但是之前模版的模版参数被限制为只能使用 class。 更多信息参考 N4051。 允许对所有非类型模版实参进行常量估算 移除对指针、引用、成员指针作为非类型模版参数时的语法限制。 更多信息参考 N4268。 萃取中的变量模版 所有产出 ::value 的类型萃取都有一个伴随的 _v 变量模版。比如： std::is_integral&lt;T&gt;::value 可以变成 std::is_integral_v&lt;T&gt; std::is_class&lt;T&gt;::value 可以变成 std::is_class_v&lt;T&gt; 此改进源自 C++14 对返回 ::type 类型萃取添加的 _t 后缀（类型别名）。 更多信息参考 P0006R0。 using 声明中的包展开 此特性是对可变参模版和参数包的加强。 现在编译器支持在包扩展中使用 using 关键字： 123template&lt;class... Ts&gt; struct overloaded : Ts... {using Ts::operator()...;}; overloaded 类暴露所有来自基类的 operator() 重载版本。C++17 之前你必须递归使用参数包以实现相同结果。 overloaded 模式是对 std::visit 一个很有用的加强，在（后边）Variant 一章的 Overload 小节有更多讨论。 更多信息参考 P0195。 逻辑操作元函数 C++17 添加了一些趁手的模版元函数： template&lt;class... B&gt; struct conjunction; - 逻辑与 template&lt;class... B&gt; struct disjunction; - 逻辑或 template&lt;class B&gt; struct negation; - 逻辑非 这里是一份基于提案代码的示例： 123456template&lt;typename... Ts&gt;std::enable_if_t&lt;std::conjunction_v&lt;std::is_same&lt;int, Ts&gt;...&gt; &gt;PrintIntegers(Ts ... args){ (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; '\\n';} PrintIntegers 函数同一组可变数量的参数一起工作，但是参数必须都是 int 类型。 这些辅助类元函数能提高复杂模版代码的可读性。 更多信息参考 P0013。 4.6 编译器支持略。","link":"/C++17%E8%AF%A6%E8%A7%A314.html"},{"title":"C++17 详解 15","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 5. 标准属性（attribute）代码注解——属性——可能不是 C++ 最为人所知的特性。但是，属性却可能便于对编译器和其他程序员传达附加信息。C++11 起有了标准方式来声明属性。C++17 里你将能获得更多属性相关的有用的附加信息。 本章你将学到： C++ 里属性是什么 厂商特有的代码注解 V.S. 标准格式 什么情况下属性是有用的 C++11 和 C++14 属性 C++17 新添加的属性 5.1 我们为什么需要属性？你是否曾在自己的代码里用过 __declspec、__attribute 或 #pragma 指示符？ 比如： 12345// 设置对齐struct S { short f[3]; } __attribute__ ((aligned (8)));// 此函数不会返回void fatal () __attribute__ ((noreturn)); 或是在 MSVC 里导入/导出 DLL： 12345#if COMPILING_DLL #define DLLEXPORT __declspec(dllexport)#else #define DLLEXPORT __declspec(dllimport)#endif 这些都是现存的编译器特有的属性/注解格式。 所以属性是什么？ 一个属性是一段编译器可以用来生成代码的附加信息。它可能被用于优化代码或一些特定的代码生成（比如 DLL 之类，OpenMP，等等）。此外，注解（译注：等同于属性）能让你写出更有表达力的代码，并帮助其他开发者理解代码。 与 C# 等其它语言不同，C++ 里编译器确定了元信息，你不能自定义属性。C# 里你可以“继承” System.Attribute。 现代 C++ 的属性最好的点在哪呢？ 现在 C++ 里，我们有了越来越多的标准化了的属性，它们能在其它编译器里正常工作。所以我们要从编译器特有的注解转移到标准化格式上来。 下一节你将看到 C++11 之前是怎么利用属性来工作的。 5.2 C++11 之前每个编译器都引入了自己的注解集合，通常都使用了不同的关键字。 你可能会很经常地看到通篇代码里散布着 #pragma、__declspec、__attribute 这样的代码。 这里是一份 GCC/Clang 和 MSVC 里常见注解语法的列表： GCC 特有属性 GCC 以 __attribute__((attr_name)) 的格式使用注解。比如： 1int square (int) __attribute__ ((pure)); // pure function 文档： 属性语法 常见函数属性 MSVC 特有属性 微软大多使用 __declspec 关键字作为各种编译器扩展的语法。文档在这里：__declspec。 1__declspec(deprecated) void LegacyCode() { } Clang 特有属性 Clang 因为方便定制，能支持不同的注解类型，可以查阅文档获取更多信息。大多数 GCC 注解都可以在 Clang 下工作。 文档在这里：属性手册。 5.3 C++11/14 属性C++11 在最小化厂商特有语法需求方面迈出了一大步。通过引入标准格式，我们能把大量编译器特有属性转换到标准集合中。 C++11 提供了一种更美观的形式以在我们的代码中声明属性。 基本语法就是 [[attr]] 或 [[namespace::attr]]。 你可以在几乎任何事物上使用 [[attr]]：类型、函数、枚举，等等等等。 比如： 12[[abc]] void foo(){} C++11 里有如下属性： [[noreturn]]： 不会返回的函数。如果带有此属性的函数返回，行为未定义。 比如 [[noreturn]] void terminate() noexcept； std::abort 和 std::exit 函数均以此属性标记。 [[carries_dependency]]： Indicates that the dependency chain in release-consume std::memory_order propagates in and outof the function, which allows the compiler to skip unnecessary memory fence instructions. Mostlyto help to optimise multi-threaded code and when using different memory models. 译注：memory order 相关，用于无锁编程，译者一窍不通，不译。 C++14 添加的： [[deprecated]] 和 [[deprecated(“reason”)]]： 使用被此属性标记的代码将被编译器报告。你可以设置为什么的“理由”。 [[deprecated]] 示例： 1234[[deprecated(\"use AwesomeFunc instead\")]] void GoodFunc() { }// 调用:GoodFunc(); GCC 可能会报出 warning： 12warning: 'void GoodFunc()' is deprecated: use AwesomeFunc instead[-Wdeprecated-declarations] 现在你知道了一点老方案，C++11/14 里的新方式……那 C++17 里又干了什么呢？ 5.4 C++17 新增C++17 里我们有了另外三种标准属性： [[fallthrough]] [[nodiscard]] [[maybe_unused]] 还添加了三种支持的特性。 扩展：新属性在 P0188 和 P0068（讨论） 中规范。 先来看新属性： [[fallthrough]] 属性 指示 switch 语句中的直落是有意的，相关的 warning 不应被发出。 123456789switch (c) {case 'a': f(); // Warning! 直落可能是一个人为错误case 'b': g();[[fallthrough]]; // Warning 被抑制，直落 OKcase 'c': h();} 通过此属性，编译器能理解程序员的意图。相比使用注释，属性更具有可读性。 [[maybe_unused]] 属性 通过声明为 [[maybe_unused]] 来抑制编译器对未使用实体的 warning。 1234567static void impl1() { ... } // 编译器可能会对此发出警告[[maybe_unused]] static void impl2() { ... } // Warning 被抑制void foo() { int x = 42; // 编译器可能会对此发出警告 [[maybe_unused]] int y = 42; // Warning 被抑制} [[nodiscard]] 属性 [[nodiscard]] 可被用于函数或类型声明以标记返回值的重要性： 1234[[nodiscard]] int Compute();void Test() { Compute(); // Warning! nodiscard 函数的返回值被舍弃了。} 如果你忘了将结果赋值给变量，编译器就会抛出 warning。 这意味着你可以强制用户处理错误。比如：如果你忘了使用 new 或 std::async() 的返回值会发生什么？ 另外，此属性可被用于类型。一种使用情景是错误码类型： 12345678910enum class [[nodiscard]] ErrorCode { OK, Fatal, System, FileIssue};ErrorCode OpenFile(std::string_view fileName);ErrorCode SendEmail(std::string_view sendto, std::string_view text);ErrorCode SystemCall(std::string_view text); 现在每次你调用这些函数时你都会被“强制”检查返回值。对重要函数来说检查返回值可能是至关重要的，使用 [[nodiscard]] 可能会让你少写几个 bug。 你也可能会问“使用”返回值是什么意思？ 标准里它被定义为弃值表达式，所以如果你的函数调用只产生副作用（没有被用作 if 语句或赋值），将鼓励编译器报告一个 warning。 为了抑制这种 warning 你可以显式地把返回值转换 void，或使用 [[maybe_unused]]： 123456[[nodiscard]] int Compute();void Test() { static_cast&lt;void&gt;(Compute()); [[maybe_unused]] auto ret = Compute();} 另外，C++20 标准库会把 [[nodiscard]] 应用在一些地方：operator new、std::async()、std::allocate()、std::launder() 和 std::empty()。此特性已通过 P0600R1 合并进了 C++20。 命名空间和枚举值上的属性 C++11 里属性的本意是可以将它们应用于所有可感知的地方：类、函数、变量、typedef、模版、枚举……但是遇到一些问题阻止了属性被用于命名空间和枚举值上。 C++17 里这个问题修复了。现在写下： 123456789101112namespace [[deprecated(\"use BetterUtils\")]] GoodUtils { void DoStuff() { }}namespace BetterUtils { void DoStuff() { }}int main(){ GoodUtils::DoStuff();} 时 Clang 会报出： 12warning: 'GoodUtils' is deprecated: use BetterUtils[-Wdeprecated-declarations] 另一个例子是把 deprecated 属性用于枚举值： 1234567891011enum class ColorModes{ RGB [[deprecated(\"use RGB8\")]], RGBA [[deprecated(\"use RGBA8\")]], RGBA16F, RGB8, RGBA8};// use:auto colMode = ColorModes::RGBA; GCC 里会得到： 12warning: 'RGBA' is deprecated: use RGBA8[-Wdeprecated-declarations] 扩展：本修改在 N4266（措辞） 和 N4196（讨论） 中描述。 忽略未知属性 此特性主要为了澄清。 C++17 之前如果你尝试使用某个编译器特定的属性，在另一个不支持它的编译器里编译时可能会得到一个编译错误。现在编译器会忽略这个属性声明，并且不会抛出任何错误（或者只是一个警告）。这点在之前的标准里并未提及，所以它需要澄清。 123// 不支持 MyCompilerSpecificNamespace 的编译器会忽略此属性[[MyCompilerSpecificNamespace::do_special_thing]]void foo(); 比如 GCC7.1 里会产生 warning： 123warning: 'MyCompilerSpecificNamespace::do_special_thing'scoped attribute directive ignored [-Wattributes]void foo(); 扩展：本修改在 P0283R2（措辞） 和 P0283R1（讨论） 中描述。 不必重复属性命名空间 此特性简化了用到多属性的用例，比如： 1234void f() { [[rpr::kernel, rpr::target(cpu,gpu)]] // 重复 doTask();} 提议的修改： 1234void f() { [[using rpr: kernel, target(cpu,gpu)]] doTask();} That simplification might help when building tools that automatically translate annotated code of that type into different programming models. 译注：没想到这是怎么样一个应用场景。 扩展：更多信息在：P0028R4。 5.5 小结C++17 里所有可用属性： [[noreturn]] [[carries_dependency]] [[deprecated]] [[deprecated(“reason”)]] [[fallthrough]] [[nodiscard]] [[maybe_unused]] 编译器厂商可以声明自己的语法、属性列表和扩展。现代 C++ 里标准委员会试图提取属性的通用部分，目标是只坚持标准属性。但是这取决于你的平台。比如在嵌入式环境里可能会有很多必需的平台相关的注解以使代码和硬件粘在一起。 这里有一份非常重要的来自 Bjarne Stroustrup 关于 C++11 FAQ/属性的摘记： 有理由担心属性将被用于创建语言方言。建议只使用属性来控制不影响程序含义但可能有助于检测错误（例如 [[noreturn]]）或帮助优化器（例如 [[carries_dependency]]）的事物。 5.6 编译器支持略。","link":"/C++17%E8%AF%A6%E8%A7%A315.html"},{"title":"C++17 详解 16 — 标准库变动","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 第二部分——标准库变动本部分你将学到： 如何通过 std::optional 表达可空（nullable）类型 什么是 tagged union？我们为什么需要 std::variant 这样类型安全的 union 如何通过 std::any 表达任意类型 如何利用 string_view 提高性能并且不破坏你的程序 标准库里都有哪些针对字符串的新加操作 如何利用标准库处理文件系统 什么是并行算法 译注：关于并行算法，我之前已经吐槽过了。结论是不能用，不必期许过深。","link":"/C++17%E8%AF%A6%E8%A7%A316-%E6%A0%87%E5%87%86%E5%BA%93%E5%8F%98%E5%8A%A8.html"},{"title":"C++17 详解 17 — std::optional","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 6. std::optionalstd::optional 可表达可空类型。 头文件： 1#include &lt;optional&gt; std::optional 是一种值类型，即执行深拷贝。它不会引入额外的动态内存分配。 用例： 12345678910111213// UI class...std::optional&lt;std::string&gt; UI::FindUserNick(){ if (IsNickAvailable()) return mStrNickName; // return a string return std::nullopt; // same as return { };}// use:std::optional&lt;std::string&gt; UserNick = UI-&gt;FindUserNick();if (UserNick) Show(*UserNick); 6.1 创建 std::optional 初始化为空： 12std::optional&lt;int&gt; oEmpty;std::optional&lt;float&gt; oFloat = std::nullopt; 直接赋值 12std::optional&lt;int&gt; oInt(10);std::optional oIntDeduced(10); // 自动推断 std::make_optional 12auto oDouble = std::make_optional(3.0);auto oComplex = std::make_optional&lt;std::complex&lt;double&gt;&gt;(3.0, 4.0); std::in_place 1234std::optional&lt;std::complex&lt;double&gt;&gt; o7{std::in_place, 3.0, 4.0};// 会通过 {1, 2, 3} 对 vector 进行直接初始化std::optional&lt;std::vector&lt;int&gt;&gt; oVec(std::in_place, {1, 2, 3}); 从其它 optional 拷贝 1auto oIntCopy = oInt; 关于 std::in_place 译注： in place 即原地、就地的意思，指通过参数列表直接调用类型的构造函数进行构造。同 C++11 之后许多容器新增的 emplace 一个作用。 std::in_place 是 std::in_place_t 类型的内置常量。 提升性能 如果没有这个参数，当你写下： 1std::optional&lt;std::string&gt; ostr{std::string{\"Hello World\"}}; 时，会匹配到 optional 的移动构造函数。即： 先通过 string 移动构造出临时 optional 对象； 再从临时 optional 对象转移构造 ostr 对象。 有了 std::in_place，只需一步： 直接将 string 参数传递给 ostr 构造函数。 默认构造 有这样一个类： 12345678class UserName{public: UserName() : mName(\"Default\") { } // ...}; 要构造一个默认值的 UserName 对象该怎么做？ 12std::optional&lt;UserName&gt; u0; // empty optionalstd::optional&lt;UserName&gt; u1{}; // also empty 这样创建的是空的 optional； 1std::optional&lt;UserName&gt; u2{UserName()}; 这样同 1 中描述的情况一样，会产生临时对象，不算默认构造。 正确做法是这样： 1std::optional&lt;UserName&gt; opt{std::in_place}; 使 optional 可存储不可拷贝/移动类型 比如 std::mutex，如果没有 std::in_place，optional&lt;mutex&gt; 就不成立。 std::make_optional 跟 std::in_place 一样作用 12345auto opt = std::make_optional&lt;UserName&gt;();auto opt = std::make_optional&lt;Point&gt;(0, 0);// 跟下边两句等价std::optional&lt;UserName&gt; opt{std::in_place};std::optional&lt;Point&gt; opt{std::in_place_t, 0, 0}; 6.3 访问存储值 operator* 和 operator-&gt; ——如果 std::optional 为空行为未定义 12std::optional&lt;int&gt; oint = 10;std::cout&lt;&lt; \"oint \" &lt;&lt; *oint &lt;&lt; '\\n'; value() ——如果空抛出 std::bad_optional_access 异常 123456789std::optional&lt;std::string&gt; ostr(\"hello\");try{ std::cout &lt;&lt; \"ostr \" &lt;&lt; ostr.value() &lt;&lt; '\\n';}catch (const std::bad_optional_access&amp; e){ std::cout &lt;&lt; e.what() &lt;&lt; '\\n';} value_or(defaultVal) ——如果空返回 defaultVal 12std::optional&lt;double&gt; odouble; // emptystd::cout&lt;&lt; \"odouble \" &lt;&lt; odouble.value_or(10.0) &lt;&lt; '\\n'; 6.4 其它操作修改值 emplace：原地构造存储值。如果当前不为空，当前值会被销毁。 reset：销毁当前值，并置为空。 swap：交换两个 optional 的值。 比较 两个空 optional 相等 空 optional 总是小于非空 optional 两个非空 optional 以其值类型的比较操作符进行比较 12345678910111213int main(){ std::optional&lt;int&gt; oEmpty; std::optional&lt;int&gt; oTwo(2); std::optional&lt;int&gt; oTen(10); std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; (oTen &gt; oTwo) &lt;&lt; '\\n'; // true std::cout &lt;&lt; (oTen &lt; oTwo) &lt;&lt; '\\n'; // false std::cout &lt;&lt; (oEmpty &lt; oTwo) &lt;&lt; '\\n'; // true std::cout &lt;&lt; (oEmpty == std::nullopt) &lt;&lt; '\\n'; // true std::cout &lt;&lt; (oTen == 10) &lt;&lt; '\\n'; // true} 6.6 慎用 std::optional 和 optional&lt;T*&gt;因为 bool 和 T* 本身就已代表一种二态值，强行将其跟 std::optional 组合成三态不够自然，会增加开发人员心智负担。","link":"/C++17%E8%AF%A6%E8%A7%A317-optional.html"},{"title":"FFmpeg 截取 webp 动图","text":"FFmpeg 支持对动态 webp 图片的编码，但是默认参数下编码后的图片有两个比较明显的问题： 动图不会自动循环播放，会停留在最后一帧画面 图像质量差，有比较明显的马赛克 动图自动循环播放 1.1 命令行下 1ffmpeg -i input.mp4 -loop 0 output.webp 1.2 libavformat 库下 1av_opt_set_int(formatContext, \"loop\", 0, AV_OPT_SEARCH_CHILDREN); 将 loop 值设置为 0，即为自动循环播放。默认值为 1。 注意，loop 是 AVFormatContext 中的选项，不是 AVCodecContext 的选项。 调整质量 libwebp 有 4 个质量相关的参数： lossless：是否无损编码 compression_level：压缩等级，0-6，值越大质量越好，默认值为 4 qscale，0-100 间的 float，值越大质量越好，默认值为 75 preset，几种预设配置，比如数字图片、户外自然相片等 粗略测试，只有 qscale 效果比较明显且副作用较小。 1.1 命令行下 使用编码器通用选项 qscale： 1ffmpeg -i input.mp4 -qscale 85 output.webp 1.2 libavcodec 库下 实测通过： 1av_opt_set_double(videoCodec, \"qscale\", 85, AV_OPT_SEARCH_CHILDREN); 方式修改 qscale 无效，必须修改 AVCodecContext::global_quality： 1videoCodec-&gt;global_quality = 85 * FF_QP2LAMBDA; 这句才能起到上边命令行一样的作用。 85 是一个比较理想的值，可以生成 gif 同样质量的动态图片。相比默认值 75，会增加 50% 左右的体积；但是相比 gif，依然有一倍有余的优势。","link":"/FFmpeg%E6%88%AA%E5%8F%96webp%E5%8A%A8%E5%9B%BE.html"},{"title":"C++17 详解 18 — std::variant","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 7. std::variantvariant 是一种类型安全的 union。 头文件： 1#include &lt;variant&gt; 综合应用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Chapter Variant/variant_demo.cpp#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;variant&gt;using namespace std;// used to print the currently active typestruct PrintVisitor{ void operator()(int i) { cout &lt;&lt; \"int: \" &lt;&lt; i &lt;&lt; '\\n'; } void operator()(float f) { cout &lt;&lt; \"float: \" &lt;&lt; f &lt;&lt; '\\n'; } void operator()(const string&amp; s) { cout &lt;&lt; \"str: \" &lt;&lt; s &lt;&lt; '\\n'; }};int main(){ variant&lt;int, float, string&gt; intFloatString; static_assert(variant_size_v&lt;decltype(intFloatString)&gt; == 3); // 默认以第一个选项进行默认初始化，值为 0。 visit(PrintVisitor{}, intFloatString); // index 指示当前所用类型 cout &lt;&lt; \"index = \" &lt;&lt; intFloatString.index() &lt;&lt; endl; intFloatString = 100.0f; cout &lt;&lt; \"index = \" &lt;&lt; intFloatString.index() &lt;&lt; endl; intFloatString = \"hello super world\"; cout &lt;&lt; \"index = \" &lt;&lt; intFloatString.index() &lt;&lt; endl; // try with get_if: if (const auto intPtr = get_if&lt;int&gt;(&amp;intFloatString)) cout &lt;&lt; \"int: \" &lt;&lt; *intPtr &lt;&lt; '\\n'; else if (const auto floatPtr = get_if&lt;float&gt;(&amp;intFloatString)) cout &lt;&lt; \"float: \" &lt;&lt; *floatPtr &lt;&lt; '\\n'; if (holds_alternative&lt;int&gt;(intFloatString)) cout &lt;&lt; \"the variant holds an int!\\n\"; else if (holds_alternative&lt;float&gt;(intFloatString)) cout &lt;&lt; \"the variant holds a float\\n\"; else if (holds_alternative&lt;string&gt;(intFloatString)) cout &lt;&lt; \"the variant holds a string\\n\"; // try/catch and bad_variant_access try { auto f = get&lt;float&gt;(intFloatString); cout &lt;&lt; \"float! \" &lt;&lt; f &lt;&lt; '\\n'; } catch (bad_variant_access&amp;) { cout &lt;&lt; \"our variant doesn't hold float at this moment...\\n\"; }} 输出： 123456int: 0index = 0index = 1index = 2the variant holds a stringour variant doesn't hold float at this moment... 示例有几个点值得注意： 如果没有进行值初始化，variant 使用第一个类型初始化。此时，第一个类型必须存在默认构造函数。 index() 返回当前使用的类型的索引；bool holds_alternative 函数检查当前使用类型是否是 Type。 get&lt;Index&gt;、get&lt;Type&gt; 返回当前索引/使用类型的值，如果当前使用类型和 Index/Type 不匹配，会抛出 bad_variant_access 异常。 get_if&lt;Index&gt;、get_if&lt;Type&gt; 返回当前索引/使用类型的变量的指针，如果当前使用类型和 Index/Type 不匹配，返回 nullptr。 可以配合 std::visit 使用。 7.1 创建 std::in_place_index、std::in_place_type 显式赋值 12variant&lt;vector&lt;int&gt;, string&gt; v{ std::in_place_index&lt;0&gt;, { 0, 1, 2, 3 } };variant&lt;vector&lt;int&gt;, string&gt; v{ std::in_place_type&lt;int&gt;, { 0, 1, 2, 3 } }; 显式指定当前索引/类型，并使用后续参数进行原地构造。 std::monostate 选项 1variant&lt;monostate, Type-Without-Default-Constructor&gt; v; monostate 是 STL 提供的一个辅助类，通常用于 variant 第一个类型，可以解决第一个选项没有默认构造函数导致 variant 变量不能默认构造的问题。 monostate 可以出现在任何位置，也可以存在多个，但是违背本意。 7.2 修改 emplace&lt;Index&gt;、emplace&lt;Type&gt;，支持基于索引/类型的原地构造。 7.3 访问存储值 get、get_if 都不是 variant 的成员函数 variant 上的访问者（visitor） 同 std::variant 一起引入的还有一个好用的 STL 函数：std::visit。 它可以对所有传入的 variant 调用一个 “访问者”。 声明如下： 12template &lt;class Visitor, class... Variants&gt;constexpr visit(Visitor&amp;&amp; vis, Variant&amp;&amp;... vars); visit 会对 variant 当前使用类型调用 vis。 如果只传入一个 variant，你必须重载 variant 里所有类型（的 operator()）。如果传入两个 variant，你必须重载这两个 variant 所有可能的类型组合。 访问者是“一个可调用对象，它接受每一个 variant 里每一种可能的选项”。 泛型 lambda 实现的访问者示例： 12345// 泛型 lambda:auto PrintVisitor = [](const auto&amp; t) { std::cout &lt;&lt; t &lt;&lt; '\\n'; };std::variant&lt;int, float, std::string&gt; intFloatString { \"Hello\" };std::visit(PrintVisitor, intFloatString); 访问者同样可以修改 variant 的值，只需将访问者参数改为非常量引用。 大多数情况下，我们会希望对不同类型执行不同的动作，这时候就需要重载 operator()。 2.1 overload 模板类实现 1234// overload 类模板声明template&lt;class... Ts&gt; struct overload : Ts... { using Ts::operator()...; };// 前文提到过的推断指引template&lt;class... Ts&gt; overload(Ts...) -&gt; overload&lt;Ts...&gt;; 2.2 std::visit 中使用 overload 123456789std::variant&lt;int, float, std::string&gt; myVariant;std::visit( overload { [](const int&amp; i) { std::cout &lt;&lt; \"int: \" &lt;&lt; i; }, [](const std::string&amp; s) { std::cout &lt;&lt; \"string: \" &lt;&lt; s; }, [](const float&amp; f) { std::cout &lt;&lt; \"float: \" &lt;&lt; f; } }, myVariant); 访问多个 variant std::visit 允许传入多个 variant，表现是依序分别将每个 variant 中的当前类型作为访问者函数的参数。这就要求访问者必须能处理所有可能的类型组合。 比如： 12std::variant&lt;int, float, char&gt; v1 { 's' };std::variant&lt;int, float, char&gt; v2 { 10 }; 可以通过提供 9 个重载实现访问者： 1234567891011std::visit(overload{ [](int a, int b) { }, [](int a, float b) { }, [](int a, char b) { }, [](float a, int b) { }, [](float a, float b) { }, [](float a, char b) { }, [](char a, int b) { }, [](char a, float b) { }, [](char a, char b) { }}, v1, v2); 可以添加泛型 lambda 版本的重载批量处理一些无效组合： 1234567891011121314151617181920std::variant&lt;Pizza, Chocolate, Salami, IceCream&gt; firstIngredient { IceCream() };std::variant&lt;Pizza, Chocolate, Salami, IceCream&gt; secondIngredient { Chocolate()};std::visit(overload{ [](const Pizza&amp; p, const Salami&amp; s) { std::cout &lt;&lt; \"here you have, Pizza with Salami!\\n\"; }, [](const Salami&amp; s, const Pizza&amp; p) { std::cout &lt;&lt; \"here you have, Pizza with Salami!\\n\"; }, [](const Chocolate&amp; c, const IceCream&amp; i) { std::cout &lt;&lt; \"Chocolate with IceCream!\\n\"; }, [](const IceCream&amp; i, const Chocolate&amp; c) { std::cout &lt;&lt; \"IceCream with a bit of Chocolate!\\n\"; }, [](const auto&amp; a, const auto&amp; b) { std::cout &lt;&lt; \"invalid composition...\\n\"; },}, firstIngredient, secondIngredient); 7.4 其它操作 比较 如果当前使用类型相同，使用相应类型的比较操作符比较； 如果当前类型不相同，以 index() 进行比较。 variant 是值类型，可以移动。 可以对 std::variant 执行 std::hash。 7.5 性能 &amp; 内存考量 同 optional 一样，variant 以尺寸最大的选项确定自身占用空间，另外有一个标识当前索引的变量。因为总是相邻存在，这个额外的标识有可能影响 CPU cache。 同 optional 一样，variant 不会动态分配内存。","link":"/C++17%E8%AF%A6%E8%A7%A318-variant.html"},{"title":"C++17 详解 19 — std::any","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 8. std::anystd::optional 可以表示一个二态值：空值、非空值； std::variant 表示一个指定类型集合内的类型； std::any 更进一步，它可以存储任何类型。 综合用例： 12345678910111213141516171819202122232425262728293031323334353637383940414243// Chapter Any/any_demo.cppstd::any a(12);// 设置值：a = std::string(\"Hello!\");a = 16;// 读取值// 按 int 读取：std::cout &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; '\\n';// 不能按 string 读取：try{ std::cout &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; '\\n';}catch(const std::bad_any_cast&amp; e){ std::cout &lt;&lt; e.what() &lt;&lt; '\\n';}// reset 然后检查 any 是否存储了某个值：a.reset();if (!a.has_value()){ std::cout &lt;&lt; \"a is empty!\" &lt;&lt; '\\n';}// 可以把 any 用在容器中：std::map&lt;std::string, std::any&gt; m;m[\"integer\"] = 10;m[\"string\"] = std::string(\"Hello World\");m[\"float\"] = 1.0f;for (auto &amp;[key, val] : m){ if (val.type() == typeid(int)) std::cout &lt;&lt; \"int: \" &lt;&lt; std::any_cast&lt;int&gt;(val) &lt;&lt; '\\n'; else if (val.type() == typeid(std::string)) std::cout &lt;&lt; \"string: \" &lt;&lt; std::any_cast&lt;std::string&gt;(val) &lt;&lt; '\\n'; else if (val.type() == typeid(float)) std::cout &lt;&lt; \"float: \" &lt;&lt; std::any_cast&lt;float&gt;(val) &lt;&lt; '\\n';} 代码输出： 12345616bad any_casta is empty!float: 1int: 10string: Hello World 上边的例子向我们揭示了一些事实： std::any 跟 std::variant、std::optional 不同，它不是模版类。 std::any 默认不包含任何值，可以通过 .has_value() 检查是否有值。 可以通过 .reset() 重置 std::any 对象。 std::any 基于“退化了的”类型运行——所以在赋值、初始化或 emplace 之前类型会通过 std::decay 转换。 当使用一个其它类型赋值时，当前类型会被销毁。 可以使用 std::any_cast&lt;T&gt; 函数访问值，如果当前类型跟 T 不同会抛出 bad_any_cast 异常。 可以通过 .type() 获取当前类型，它返回当前类型的 std::type_info。 8.1 创建 std::in_place_type 原地构造 12std::any a4{std::in_place_type&lt;MyType&gt;, 10, 11};std::any a5{std::in_place_type&lt;std::string&gt;, \"Hello World\"}; std::make_any 1std::any a6 = std::make_any&lt;std::string&gt;(\"Hello World\"); 8.2 修改值 emplace 123a.emplace&lt;float&gt;(100.5f);a.emplace&lt;std::vector&lt;int&gt;&gt;({10, 11, 12, 13});a.emplace&lt;MyType&gt;(10, 11); std::any_cast 1std::any_cast&lt;MyType&amp;&gt;(var).a = 11; 12int* p = std::any_cast&lt;MyType&gt;(&amp;var);p-&gt;a = 12; std::any_cast 有多个重载版本，如上两个，可以返回持有类型的指针或引用。 8.3 访问存储值只能通过 std::any_cast 访问 std::any。 8.4 性能 &amp; 内存考量std::any 因为意图存储任意类型，需要的内存空间是不确定的，所以需要动态分配内存。为了尽量避免动态内存分配，std::any 跟 std::string 一样采用了 SBO（Small Buffer Optimization），即预先分配若干字节的栈空间，仅当存储类型尺寸大于栈空间时才进行动态内存分配。","link":"/C++17%E8%AF%A6%E8%A7%A319-any.html"},{"title":"C++17 详解 20 — std::string_view","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 9. std::string_view头文件： 1#include &lt;string_view&gt; string_view 是 string 的“视图”。它不拥有 string，也不会复制其内容，但你却可以通过 string_view 进行一些 string 相关的操作，从而避免不必要的复制。 比如： 12345678910// string function:std::string StartFromWordStr(const std::string&amp; strArg, const std::string&amp; word){ return strArg.substr(strArg.find(word)); // substr creates a new string}// call:std::string str {\"Hello Amazing Programming Environment\" };auto subStr = StartFromWordStr(str, \"Programming Environment\");std::cout &lt;&lt; subStr &lt;&lt; '\\n'; 上边代码会执行至少三次字符串复制： str 定义时 函数构造第二个参数时：需要从 const char* 转换成 string 对象 subStr 初始化 这种 substr 操作就很适合用 string_view 进行优化： 123456789std::string_view StartFromWord(std::string_view str, std::string_view word){ return str.substr(str.find(word)); // substr creates only a new view}// call:std::string str {\"Hello Amazing Programming Environment\"};auto subView = StartFromWord(str, \"Programming Environment\");std::cout &lt;&lt; subView &lt;&lt; '\\n'; 上边代码只进行一次字符串的复制—— str 定义。string_view 通常只持有指向字符串起始位置的指针和长度，所以它是很轻量的。 译注：GCC 下 sizeof(string_view) = 16。所以再轻量，作为函数参数传递时该用引用还是得用！ std::basic_string_view 类型 同 string 一样，string_view 也是一系列模板类的简称： 1234std::string_view std::basic_string_view&lt;char&gt;std::wstring_view std::basic_string_view&lt;wchar_t&gt;std::u16string_view std::basic_string_view&lt;char16_t&gt;std::u32string_view std::basic_string_view&lt;char32_t&gt; 创建 从一个带终止符（\\0）的 const char* 字符串创建 1234const char* cstr = \"Hello World\";std::string_view sv1 { cstr };std::cout &lt;&lt; sv1 &lt;&lt; \", len: \" &lt;&lt; sv1.size() &lt;&lt; '\\n'; // 11 从 const char* 和一个长度创建 1234const char* cstr = \"Hello World\";std::string_view sv2 { cstr, 5 };std::cout &lt;&lt; sv2 &lt;&lt; \", len: \" &lt;&lt; sv2.size() &lt;&lt; '\\n'; // 5 从 std::string 创建 123std::string str = \"Hello String\";std::string_view sv3 = str;std::cout &lt;&lt; sv3 &lt;&lt; \", len: \" &lt;&lt; sv3.size() &lt;&lt; '\\n'; // 11 通过 “”sv 字面量创建 1234using namespace std::literals;std::string_view sv4 = \"Hello\\0 Super World\"sv;std::cout &lt;&lt; sv4 &lt;&lt; \", len: \" &lt;&lt; sv4.size() &lt;&lt; '\\n';std::cout &lt;&lt; sv4.data() &lt;&lt; \" - till zero\\n\"; 输出： 12Hello Super World, len: 18Hello - till zero data() 返回指向首字符的指针，所以 cout 输出时遇到终止符时即停止打印。 其它操作 一个大概总结： 既然 string_view 是对 string 的虚代理，那合理推测是 string_view 应提供同 string 相同的操作接口；又因 string_view 不持有字符串，只做视图用，那 string_view 应剔除修改相关（即非 const）接口。 对 string_view 自身属性的访问： remove_prefix(size_t n) 将 string_view 持有的指针向前移动 n 个位置（+n），string_view::size() 随之减小 n。n &gt; string_view::size() 行为未定义。 remove_suffix(size_t n) 将 string_view::size() 减小 n。n &gt; string_view::size() 行为未定义。 swap 交换两个 string_view 对象内容，即指针和尺寸。 风险 data() 12345std::string s = \"Hello World\";std::cout &lt;&lt; s.size() &lt;&lt; '\\n';std::string_view sv = s;auto sv2 = sv.substr(0, 5);std::cout &lt;&lt; sv2.data() &lt;&lt; '\\n'; /// ooops? 如之前提到的，data() 返回的是起始位置的字符指针（const char*），以 data() 返回值进行打印输出很可能得不到你想要的结果。 进行基于字符串的转换时也有此问题： 1234std::string number = \"123.456\";std::string_view svNum { number.data(), 3 };auto f = atof(svNum.data()); // 注意这句std::cout &lt;&lt; f &lt;&lt; '\\n'; 你很可能期望 f 值等于 123，但实际 f = 123.456 引用对象生命周期 还是最开始时候的函数： 1234std::string_view StartFromWord(std::string_view str, std::string_view word){ return str.substr(str.find(word)); // substr creates only a new view} 但如果以临时对象调用会怎么样？ 123auto str = \"My Super\"s;auto sv = StartFromWord(str + \" String\", \"Super\");// 开始使用 sv 对 sv 的操作将导致运行时错误。 译注： 其实 string_view 跟智能指针的设计思路是一样的，都是享元设计模式的具体体现。 因为 string_view 处理的是字符串相关，在通常的引用对象生命周期问题外引入了字符串领域的空字符问题。这其实也不是一个新鲜问题，如果你有用 string 作为字节缓冲区（而非字符串）的经历，你一定也对 string::data() 中的坑不陌生。 性能 &amp; 内存考量 string_view 通常以 [ptr, length] 结构实现，很轻量； string_view 上的字符串操作同 string 中的同类操作具有一致的复杂度； string_view 中的字符串操作函数绝大多数都是 constexpr 的： 1234567891011#include &lt;string_view&gt;int main(){ using namespace std::literals; constexpr auto strv = \"Hello Programming World\"sv; constexpr auto strvCut = strv.substr(\"Hello \"sv.size()); static_assert(strvCut == \"Programming World\"sv); return strvCut.size();} 如上，strv、strvCut 都是在编译期构造的。","link":"/C++17%E8%AF%A6%E8%A7%A320-string_view.html"},{"title":"C++17 详解 21 — 字符串转换","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 10. 字符串转换两类函数： from_chars —将字符串转换成整数、浮点数等 to_chars —将数字转换成字符串 为了确保性能，这些函数有如下保证： 不抛出异常——任何情况下都不抛出异常 不分配内存——所有操作均是原地进行的，没有额外的内存分配 不支持本地化——所有字符串均以默认 locale 解析 内存安全——指明输入输出范围以允许做缓冲区安全（溢出等）检查 不需要传递字符串格式 对转换错误报告附加信息 用 from_chars 将字符串转换成数字 整数型适用函数： 1234std::from_chars_result from_chars(const char* first, const char* last, TYPE &amp;value, int base = 10); base 取值范围 [2,36]。 浮点型适用函数： 1234std::from_chars_result from_chars(const char* first, const char* last, FLOAT_TYPE&amp; value, std::chars_format fmt = std::chars_format::general); chars_format 是一个位掩码类型的枚举类： 123456enum class chars_format { scientific = /*unspecified*/, fixed = /*unspecified*/, hex = /*unspecified*/, general = fixed | scientific}; 所有 from_chars 函数均返回 from_chars_result 类型： 1234struct from_chars_result { const char* ptr; std::errc ec;}; 转换成功时，ptr 指向第一个不匹配字符，如果所有字符全匹配则跟 last 指向同一位置；ec 执行值初始化。 转换无效时，ptr = first；ec = std::errc::invalid_argument；不修改 value。 超出范围，即数字大小超出 value 类型范围时，ec = std::errc::result_out_of_range；ptr 指向第一个不匹配字符；不修改 value。 用 to_chars 将数字转换成字符串 整型适用函数： 12std::to_chars_result to_chars(char* first, char* last, TYPE value, int base = 10); 浮点型适用函数： 12345678910std::to_chars_result to_chars(char* first, char* last, FLOAT_TYPE value);std::to_chars_result to_chars(char* first, char* last, FLOAT_TYPE value, std::chars_format fmt); std::to_chars_result to_chars(char* first, char* last, FLOAT_TYPE value, std::chars_format fmt, int precision); 所有函数都返回 std::to_chars_result 类型： 1234struct to_chars_result { char* ptr; std::errc ec;}; 成功时，ec 进行值初始化；ptr 指向最后一个字符后一个位置。注意字符串不是以空字符结束的。 出错时，ptr = first；ec = std::errc::invalid_argument。 超出范围时，ec = std::errc::value_too_large；[first, last) 范围变成未知状态。 Benchmark 作者实现了如下一种测试条件： 随机数生成 vector vector 转换成 vector，再把 vector 转换回 vector，分别测量两个阶段的耗时 分别测试如下转换接口： — from_chars/to_chars — to_string/stoi — sprintf/atoi — ostringstream/istringstream 完整的测试代码可在这里找到：https://www.cppindetail.com/data/cpp17indetail.zip —— “Chapter String Conversions/conversion_benchmark.cpp” 结果： 函数 GCC 8.2 Clang 7.0 Win VS 2017 15.8 x64 to_chars 21.94 18.15 24.81 from_chars 15.96 12.74 13.43 to_string 61.84 16.62 20.91 stoi 70.81 45.75 42.40 sprintf 56.85 124.72 131.03 atoi 35.90 34.81 32.50 ostringstream 264.29 681.29 575.95 stringstream 306.17 789.04 664.90 译注： 可惜没有做浮点型数据的测试。我早先（C++17 之前）在实现日志库时曾对标准库提供的这些转换函数做过类似的性能对比，的确如上表所列：同一函数不同编译器实现的性能差距很大！而同一函数对整型和浮点型的表现差异又天差地别。希望这个问题在 to_chars 和 from_chars 上已经不存在了。 不过如函数原型所示，结果是以传出参数形式给出的，不利于链式调用。还是继续期待 fmt 库吧。","link":"/C++17%E8%AF%A6%E8%A7%A321-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2.html"},{"title":"C++17 详解 22 — search 和字符串匹配","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 11. search 和字符串匹配11.1 新算法C++17 从两方面更新了 std::search 指定执行策略以通过并行方式运行默认算法版本 提供 Searcher 对象（译注：即三种算法）处理查找 译注：执行策略是 STL 算法通用的更新特性，后边有专门的一章讲解，所以本章只介绍了 searcher。 三种 searcher： default_searcher：行为同 C++17 之前，通常采用最朴素的方案（译注：即逐元素遍历比较）。对前向迭代器可用。 boyer_moore_searcher：使用 Boyer–Moore 算法，有两个规则：坏字符规则和好后缀规则。对随机访问迭代器可用。 boyer_moore_horspool_searcher：B.M. 算法的简化版本，只使用坏字符规则，但仍然具有很好的平均复杂度。对随机访问迭代器可用。 std::search 中 searcher 和 执行策略不能共存。 函数原型： 123template&lt;class ForwardIterator, class Searcher&gt;ForwardIterator search(ForwardIterator first, ForwardIterator last, const Searcher&amp; searcher); searcher 示例： 1234567string testString = &quot;Hello Super World&quot;;string needle = &quot;Super&quot;;const auto it = search(begin(testString), end(testString), boyer_moore_searcher(begin(needle), end(needle)); if (it == cend(testString)) cout &lt;&lt; &quot;The string &quot; &lt;&lt; needle &lt;&lt; &quot; not found\\n&quot;; 译注：B.M. 或其它高阶查找算法，大都是以空间换时间的思路。比如，以额外空间存储要查找字符串的字符集合。所以要求 searcher 是一个类对象，以存储这些额外信息。","link":"/C++17%E8%AF%A6%E8%A7%A322-search%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html"},{"title":"C++17 详解 23 —文件系统","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 12. 文件系统12.1 总览头文件： 1#include &lt;filesystem&gt; std::filesystem 是一个模块，同时也是一个命名空间。核心元素包括： std::filesystem::path 对象允许你操作代表存在或不存在的文件和目录的路径。 std::filesystem::directory_entry 表示一个存在的路径，并附带额外状态信息，比如最后修改时间、文件尺寸以及其它属性。 目录迭代器允许你遍历一个给定的目录。库提供了递归和非递归版本。 大量支持函数比如获取路径信息、文件操作、权限、创建目录等等。 12.2 综合应用实例1234567891011121314151617181920212223242526272829303132333435363738#include &lt;filesystem&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;namespace fs = std::filesystem;void DisplayDirectoryTree(const fs::path &amp;pathToScan, int level = 0) { for (const auto &amp;entry : fs::directory_iterator(pathToScan)) { const auto filenameStr = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; filenameStr &lt;&lt; '\\n'; DisplayDirectoryTree(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; filenameStr &lt;&lt; &quot;, size &quot; &lt;&lt; fs::file_size(entry) &lt;&lt; &quot; bytes\\n&quot;; } else std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot; [?]&quot; &lt;&lt; filenameStr &lt;&lt; '\\n'; }}int main(int argc, char *argv[]) { try { const fs::path pathToShow{ argc &gt;= 2 ? argv[1] : fs::current_path() }; std::cout &lt;&lt; &quot;listing files in the directory: &quot; &lt;&lt; fs::absolute(pathToShow).string() &lt;&lt; '\\n'; DisplayDirectoryTree(pathToShow); } catch (const fs::filesystem_error &amp;err) { std::cerr &lt;&lt; &quot;filesystem error! &quot; &lt;&lt; err.what() &lt;&lt; '\\n'; } catch (const std::exception &amp;ex) { std::cerr &lt;&lt; &quot;general exception: &quot; &lt;&lt; ex.what() &lt;&lt; '\\n'; }} Windows 下输出： 123456789101112131415.\\ListFiles.exe D:\\testlist\\listing files in the directory: D:\\testlist\\abc.txt, size 357 bytesdef.txt, size 430 bytesghi.txt, size 190 bytesdirTemp jkl.txt, size 162 bytes mno.txt, size 1728 bytestempDir abc.txt, size 174 bytes def.txt, size 163 bytes tempInner abc.txt, size 144 bytes mno.txt, size 1728 bytes xyz.txt, size 3168 bytes 所有类型、函数和名字都存在于 std::filesystem 命名空间内，为了方便用到了命名空间别名（namespace alias）： 1namespace fs = std::filesystem; main 函数中： 程序接受一个来自命令行的可选参数，如果为空则使用当前系统路径： 1const fs::path pathToShow{ argc &gt;= 2 ? argv[1] : fs::current_path() }; fs::absolute() 函数将输入路径转换成绝对路径。 DisplayDirectoryTree 函数中： 使用 directory_iterator 检查目录并查找（子）文件或（子）目录： 1for (const auto&amp; entry : fs::directory_iterator(pathToShow)) 每次迭代都返回一个新的 fs::directory_entry 对象。 通过 entry.is_directory() 判断当前项是否是子目录，如果是则递归调用 DisplayDirectoryTree。 12.3 path 对象std::filesystem::path 是库的核心构成。 path 由下列元素组成： root-name root-directory relative-path +（可选）root-name：POSIX 系统没有根名称。Windows 上它通常是驱动器名称，像“C:” （可选）root-directory：区分相对路径和绝对路径 relative-path： filename （可选）directory separator （可选）relative-path path 类实现了许多函数以提取路径中的各个部分： path::root_name() path::root_directory() path::root_path()：上边两部分的组合 path::relative_path() path::parent_path() path::filename() path::stem()：filename() 的前半部分 path::extension()：filename() 的扩展名部分 如果某部分在路径中不存在，上述函数会返回一个空 path 对象（path::empty() = true）。 同时，上述函数都配有一个 bool has_xxx() 的查询函数。 示例： 123456789101112131415161718192021222324252627282930313233const filesystem::path testPath{ ... };if (testPath.has_root_name()) cout &lt;&lt; &quot;root_name() = &quot; &lt;&lt; testPath.root_name() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no root-name\\n&quot;;if (testPath.has_root_directory()) cout &lt;&lt; &quot;root directory() = &quot; &lt;&lt; testPath.root_directory() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no root-directory\\n&quot;;if (testPath.has_root_path()) cout &lt;&lt; &quot;root_path() = &quot; &lt;&lt; testPath.root_path() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no root-path\\n&quot;;if (testPath.has_relative_path()) cout &lt;&lt; &quot;relative_path() = &quot; &lt;&lt; testPath.relative_path() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no relative-path\\n&quot;;if (testPath.has_parent_path()) cout &lt;&lt; &quot;parent_path() = &quot; &lt;&lt; testPath.parent_path() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no parent-path\\n&quot;;if (testPath.has_filename()) cout &lt;&lt; &quot;filename() = &quot; &lt;&lt; testPath.filename() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no filename\\n&quot;;if (testPath.has_stem()) cout &lt;&lt; &quot;stem() = &quot; &lt;&lt; testPath.stem() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no stem\\n&quot;;if (testPath.has_extension()) cout &lt;&lt; &quot;extension() = &quot; &lt;&lt; testPath.extension() &lt;&lt; '\\n';else cout &lt;&lt; &quot;no extension\\n&quot;; 输入为 “C:\\Windows\\system.ini” 时的输出： 12345678root_name() = &quot;C:&quot;root directory() = &quot;\\\\&quot;root_path() = &quot;C:\\\\&quot;relative_path() = &quot;Windows\\\\system.ini&quot;parent_path() = &quot;C:\\\\Windows&quot;filename() = &quot;system.ini&quot;stem() = &quot;system&quot;extension() = &quot;.ini&quot; POSIX 系统上，输入为 “/usr/temp/abc.txt” 时的输出： 12345678no root-nameroot directory() = &quot;/&quot;root_path() = &quot;/&quot;relative_path() = &quot;usr/temp/abc.txt&quot;parent_path() = &quot;/usr/temp&quot;filename() = &quot;abc.txt&quot;stem() = &quot;abc&quot;extension() = &quot;.txt&quot; std::filesystem::path 同时还实现了 begin() 和 end() 函数，所以你可以在 range based for 循环里使用 path： 1234567891011#include &lt;iostream&gt;#include &lt;filesystem&gt;namespace fs = std::filesystem;int main(){ const fs::path p = &quot;C:\\\\users\\\\abcdef\\\\AppData\\\\Local\\\\Temp\\\\&quot;; std::cout &lt;&lt; &quot;Examining the path &quot; &lt;&lt; p &lt;&lt; &quot; through iterators gives\\n&quot;; for (auto it = p.begin(); it != p.end(); ++it) std::cout &lt;&lt; *it &lt;&lt; &quot; │ &quot;; std::cout &lt;&lt; '\\n';} 输出： 12Examining the path &quot;C:\\users\\abcdef\\AppData\\Local\\Temp\\&quot; through iterators gives&quot;C:&quot; │ &quot;/&quot; │ &quot;users&quot; │ &quot;abcdef&quot; │ &quot;AppData&quot; │ &quot;Local&quot; │ &quot;Temp&quot; │ &quot;&quot; │ 译注：我以一个多层子目录的路径示例替换了原书示例。上边代码来自 cppreference。 12.3.1 path 操作其它重要函数： path::append() 把一个 path 和目录分隔符 append 到另一个 path 上 path::concat() 拼接 path，不带目录分隔符 path::clear() 使 path 为空 path::remove_filename() 删除路径的 filename 部分 path::replace_filename() 替换 filename 组件 path::replace_extension() 替换扩展名 path::swap() 交换两个路径 path::compare() 比较路径，返回 int path::empty() 是否为空 比较 除 path::compare() 函数外，还支持操作符比较： 1== != &lt; &gt; &lt;= &gt;= 所有方法均以路径的原生格式逐元素比较。 123456789fs::path p1 { &quot;/usr/a/b/c&quot; };fs::path p2 { &quot;/usr/a/b/c&quot; };assert(p1 == p2);assert(p1.compare(p2) == 0);p1 = &quot;/usr/a/b/c&quot;;p2 = &quot;/usr/a/b/c/d&quot;;assert(p1 &lt; p2);assert(p1.compare(p2) &lt; 0); Windows 上还能测试带 root path 的路径： 1234p1 = &quot;C:/test&quot;;p2 = &quot;abc/xyz&quot;; // 没有 root path, 所以它“小于”有 root 的 pathassert(p1 &gt; p2);assert(p1.compare(p2) &gt; 0); 同样能处理 Windows 上以不同格式表示的 path： 1234fs::path p3 { &quot;/usr/a/b/c&quot; }; // Windows 上它被转换为原生格式fs::path p4 { &quot;\\\\usr/a\\\\b/c&quot; };assert(p3 == p4);assert(p3.compare(p4) == 0); 路径组合 path::append() 添加一个目录分隔符和路径。 同样支持操作符：/ /=。 1234fs::path p1{&quot;C:\\\\temp&quot;};p1 /= &quot;user&quot;;p1 /= &quot;data&quot;;cout &lt;&lt; p1 &lt;&lt; '\\n'; // C:\\temp\\user\\data path::concat() 只添加 path 的字符串而不带目录分隔符。 操作符形式：+ += 1234fs::path p2(&quot;C:\\\\temp\\\\&quot;);p2 += &quot;user&quot;;p2 += &quot;data&quot;;cout &lt;&lt; p2 &lt;&lt; '\\n'; // C:\\temp\\userdata 如果传入 path 带有 root-name，且 root-name 跟当前 path 的 root-name 不同，append 操作会替换当前路径： 1234auto resW = fs::path{&quot;foo&quot;} / &quot;D:\\&quot;; // Windowsauto resP = fs::path{&quot;foo&quot;} / &quot;/bar&quot;; // POSIX// resW 现在是 &quot;D:\\&quot;// resP 现在是 &quot;/bar&quot; 流操作符 path 类实现了 operator &gt;&gt; 和 operator &lt;&lt;。 操作符里用到了 std::quoted 以保存正确的格式。这会导致在 Windows 上以原生格式输出 path 中的 “\\”。 比如 POSIX 上： 12fs::path p1 { &quot;/usr/test/temp.xyz&quot; };std::cout &lt;&lt; p1; 会输出 &quot;/usr/test/temp.xyz&quot;（译注：带引号输出）， Windows 上： 12fs::path p2{ &quot;usr\\\\test\\\\temp.xyz&quot; };std::cout &lt;&lt; p2; 会输出：&quot;usr\\\\test\\\\temp.xyz&quot;（译注：带引号，同时保留了 “\\”）。 路径格式和转换 路径格式有两种： 通用（generic）格式，标准格式（基于 POSIX 格式） 原生（native）格式，某些特别的实现所用 路径格式在 Windows 和 POSIX 系统上的表现是不一样的。 POSIX 系统上两种格式是一样的；Windows 上不一样。 Windows 上使用反斜杠（\\），且 Windows 上有 root-name，比如 C: D: 等。 POSIX 系统上以 char 和 std::string 存储路径字符；Windows 上用的是 wchar_t 和 std::wstring。 原生格式接口： path::c_str()：返回 value_type*，等同于 path::native().c_str() path::native()：返回 string_type&amp; 从原生格式转换接口： path::string()：转换成 string path::wstring()：转换成 wstring path::u8string()：转换成 u8string path::u16string()：转换成 u16string path::u32string()：转换成 u32string 12.4 directory_entry 和 directory_iteratorpath 可以表示一个存在或不存在的文件或路径，directory_entry 和 directory_iterator 指向存在的文件或目录。 使用 directory_iterators 遍历路径 directory_iterator：迭代单个目录，前向迭代器。 recursive_directory_iterator：递归迭代，前向迭代器。 遍历顺序都是不确定的。 如果迭代器被创建后，迭代器指向的目录树中有文件或目录被添加或删除，标准没有规范迭代器是否已知这种变化（译注：即未定义行为）。 “.” 和 “..” 这两个特殊目录会被迭代器跳过。 directory_entry （常用）方法 directory_entry::assign()：替换对象中的路径并调用 refresh() 更新缓存的属性 directory_entry::replace_filename()：替换对象中路径的 filename 并调用 refresh() 更新缓存的属性，效果等同于 path::replace_filename() directory_entry::refresh()：更新缓存的文件属性 directory_entry::exists()：检查对象中路径是否指向一个存在的文件/目录 directory_entry::is_directory() directory_entry::is_regular_file() directory_entry::file_size() directory_entry::last_write_time() directory_entry::status() 12.5 （常用）支持函数查询类： filesystem::is_directory() filesystem::is_empty() filesystem::is_regular_file() filesystem::exists() filesystem::file_size() filesystem::last_write_time() 路径相关： filesystem::absolute()：合成一个绝对路径 filesystem::canonical()：合成一个规范的绝对路径，即在其通用格式表示中无点（.）、双点（..）元素或符号链接的绝对路径；路径不存在时抛出异常 filesystem::weakly_canonical()：同 canonical()，但是不检查路径是否存在 filesystem::relative()：返回路径相对于指定路径（默认为 current_path()）的相对路径；如果两者无关联，返回空 relative (“c”,”/a/b”) == “” filesystem::proximate()：同 relative()，但是两个路径无关时返回源路径 proximate(“c”,”/a/b”) == “c” filesystem::current_path()：返回或设置当前目录 filesystem::equivalent()：检查两个路径是否指向同一个文件系统对象 目录和文件管理： filesystem::copy()：复制指定文件或目录到目标位置，可以通过 std::filesystem::copy_options 枚举控制具体的复制行为，比如是否递归、是否覆盖等 filesystem::copy_file()：复制单个文件 filesystem::create_directory()：创建新目录 filesystem::create_directories()：递归创建指定路径上不存在的目录 filesystem::permissions()：修改路径访问权限 filesystem::remove()：删除单个文件或空目录 filesystem::remove_all()：递归删除指定目录及其内容 filesystem::rename()：移动或重命名文件或目录 filesystem::resize_file()：修改文件大小，小于当前大小截断内容；大于当前以 0 填充 filesystem::space()：返回指定文件系统空间信息，比如容量、未用、可用 filesystem::status()：返回指定文件或目录的状态信息 filesystem::temp_directory_path()：返回系统临时文件目录 12.6 错误处理 &amp; 文件竞争（race） 所有 filesystem 库函数均可以用异常处理错误，同时所有函数都有一个带 error_code 参数的重载版本，可以通过 error_code 判断错误。 所有 filesystem 操作都是非线程安全的。","link":"/C++17%E8%AF%A6%E8%A7%A323-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"},{"title":"C++17 详解 24 —并行 STL 算法","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 13. 并行 STL 算法13.1 介绍不止线程 除使用多线程外，还可以通过 CPU 或 GPU 的向量指令集进行加速。 CPU 中此类方法统称 SIMD — Single Instruction Multiple Data，即单指令多数据。常见的实现有 AVX256、AVX512、NEON。 GPU 中并行计算更碎片化，大多是跟硬件绑定，比如 NVIDIA 的 CUDA，Intel 的 TBB。也存在一些硬件无关的并行库，比如 OPENCL、OPENGL、OPENMP。 C++17 在这个方向上迈出了一小步：它解锁了标准库中算法的自动向量化/自动并行化。 译注：关于并发和并行，我见过的最通俗易懂的解读是这样的： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 我个人总结：并行其实是跟串行区分比较的，所以 SIMD 这种可以同时处理多个数据的就是并行；如果多线程运行在同一个 CPU core 上，就是并发；如果多线程运行在不同的 CPU core 上，就是并行。 13.2 概览新特性在使用角度看起来超简单：只是在大多数算法函数中新加了一个参数，这个参数叫做执行策略（execution policy）。 1std::algorithm_name(policy, /* normal args... */); 示例： 123std::vector&lt;int&gt; v = genLargeVector();// 以并行策略对 vector 排序std::sort(std::execution::par, v.begin(), v.end()); std::execution::par 表示使用并行策略。由 STL 实现来决定选择最好的并行方案，通常都是利用线程池。 13.3 执行策略三类执行策略： sequenced_policy：同 C++17 之前，顺序执行。 parallel_policy：并行执行算法，如果采用多线程方式的话，每一个线程内的执行是顺序的、但是顺序不确定（即上次函数调用结束再进行下一次调用）。 parallel_unsequenced_policy：多线程 + 向量指令集，线程内、线程间均是无序的。 标准库预定义了三类策略的全局对象： std::execution::seq std::execution::par std::execution::par_unseq 限制和风险 std::execution::par 不是线程安全的，如果有用到共享数据需要自己做同步保护。 1234567891011std::vector&lt;int&gt; vec(1000);std::iota(vec.begin(), vec.end(), 0);std::vector&lt;int&gt; output;std::mutex m;std::for_each(std::execution::par, vec.begin(), vec.end(),[&amp;output, &amp;m, &amp;x](int&amp; elem) { if (elem % 2 == 0) { std::lock_guard guard(m); output.push_back(elem);}}); std::execution::par_unseq 同样不是线程安全的，而且同一线程内的执行是交错的（interleaved），如果像上面一样加锁的话，会造成死锁。 如我之前所吐槽，各编译器厂商中并行 STL 的实现进度缓慢，现在好像还不是深入研究并实战应用并行算法的时候。所以本章到此结束，原书中后续的 benchmark、新加算法介绍等内容暂时不理会了。","link":"/C++17%E8%AF%A6%E8%A7%A324-%E5%B9%B6%E8%A1%8CSTL%E7%AE%97%E6%B3%95.html"},{"title":"C++17 详解 25 —标准库的其它变动","text":"本文为 《C++17 in detail》 一书的中文渣中渣译文，不足之处还望指正。 翻译太特么累人了……剩余部分还是只做摘要翻译吧。 14. STL 其它改动14.1 std::byte类型安全的字节表示，不是数值型值。 定义： 1enum class byte : unsigned char {} ; // in &lt;cstddef&gt; 可以通过 unsigned char 初始化 b{unsigned char}，也可以通过 std::to_integer() 转换成数值类型。 14.2 map 和 set 改进拼接（splicing） 新函数：set/map::extract() 12345std::set&lt;User&gt; setNames;setNames.emplace(&quot;John&quot;);std::set&lt;User&gt; outSet;auto handle = setNames.extract(User(&quot;John&quot;));outSet.insert(std::move(handle)); 将 John 从 setNames 提取出来，然后把它插入 outSet。 extract 返回 node_type 类型的节点句柄。 node_handle 是一个只可移动类型，移动构造函数从对象中取走容器元素所有权。 User 不需要定义移动构造函数就可以使用 extract（node_handle 持有 node*，node* 持有 User）。 对 map 和 unordered_map 的 emplace 加强 新加 try_emplace() 函数：如果指定键值已经存在不做任何事情，否则执行 emplace()。 新加 insert_or_assign() 函数：插入新键值对或更新已存在键的值，值以移动构造方式转移进容器。 14.3 emplace 函数的返回值类型由 void 改为了 T&amp; 1234567// C++17 前的 std::vectortemplate&lt; class... Args &gt;void emplace_back( Args&amp;&amp;... args );// C++17 的 std::vectortemplate&lt; class... Args &gt;reference emplace_back( Args&amp;&amp;... args ); 14.4 采样算法std::sample：从序列中选择 n 个元素。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;random&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;int main() { std::vector&lt;int&gt; v { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; std::vector&lt;int&gt; out; std::sample(v.begin(), v.end(), std::back_inserter(out), 3, // 采样数量 std::mt19937{std::random_device{}()}); std::cout &lt;&lt; &quot;Sampled values: &quot;; for (const auto &amp;i : out) std::cout &lt;&lt; i &lt;&lt; &quot;, &quot;;} 14.5 新的数学函数&lt;numerics&gt; 头文件： std::gcd：最大公约数 std::lcm：最小公倍数 &lt;algorithm&gt; 头文件： std::clamp(v, min, max) &lt;cmath&gt; 头文件： assoc_laguerre assoc_legendre beta comp_ellint_1 comp_ellint_2 comp_ellint_3 cyl_bessel_i cyl_bessel_j cyl_bessel_k cyl_neumann ellint_1 ellint_2 ellint_e expint hermite laguerre legendre riemann_zeta sph_bessel sph_legendre sph_neumann 译注：完全没了解。 14.6 shared_ptr 和数组现在 shared_ptr 持有数组不需要指明自定义 deleter 了： 1std::shared_ptr&lt;int[]&gt; ptr(new int[10]); make_shared 还不支持数组，需要等到 C++20。 14.7 非成员的 size()、data()、empty()头文件： 1#include &lt;iterator&gt; size() data() empty() 14.8 标准库里 constexpr 的增加C++17 开始添加容器类的 constexpr 构造能力；C++20 添加 constexpr 算法的能力。 14.9 std::scoped_lockscoped_lock 可以对多个 mutex 同时 lock： 1std::scoped_lock lck(first_mutex, second_mutex); 14.10 std::iterator 被弃用自定义迭代器类时不需要再从 std::iterator 继承，虽然需要显式地定义类型萃取的各个部分，但是代码变得更清晰了。 旧： 12345class ColumnIterator: public std::iterator&lt;std::random_access_iterator_tag, Column&gt;{ // ...}; 新： 123456789class ColumnIterator {public: using iterator_category = std::random_iterator_tag; using value_type = Column; using difference_type = std::ptrdiff_t; using pointer = Column*; using reference = Column&amp;; // ...}; 14.11 多态化的分配器（Allocator），pmr https://en.cppreference.com/w/cpp/header/memory_resource 预置了几种不同内存分配策略的分配器。 pmr：Polymorphic Memory Resource，多态内存资源。","link":"/C++17%E8%AF%A6%E8%A7%A325-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E5%85%B6%E5%AE%83%E5%8F%98%E5%8A%A8.html"},{"title":"React + Videojs + Sanic 打造简易流播放器","text":"Html5 的 &lt;video /&gt; 只能在整个视频文件加载完成后才能播放，体验极其不好。如果仅是支持基于 Http(s) 的流媒体播放的话，可以直接利用 Http 协议的 Content-Range 头。 所以本文的核心思想是使 Sanic 后端能正确处理 Videojs 发送的 byte-range 请求，并回以带 Content-Range 的文件流响应即可。 安装 Video.js在 React 项目目录下安装 Video.js 及其主题 UI 库。 123npm install video.jsnpm install video.js @videojs/themes React 组件中使用 Video.jsApp.js 中，创建 video 对象并将其与 Video.js player 关联： 12345678910111213141516171819202122232425import './App.css';import React from 'react';import videojs from 'video.js';import &quot;video.js/dist/video-js.css&quot;;import '@videojs/themes/dist/sea/index.css';export default class App extends React.Component { componentDidMount() { // instantiate Video.js this.player = videojs(this.videoNode, this.props, function onPlayerReady() { console.log('onPlayerReady', this) }); } render() { return ( &lt;div&gt; &lt;div data-vjs-player&gt; &lt;video ref={node =&gt; this.videoNode = node} className=&quot;video-js vjs-theme-sea&quot;&gt;&lt;/video&gt; &lt;/div&gt; &lt;/div&gt; ) }} index.js 中，通过 /api/video 接口向后端发送视频请求： 1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';const videoJsOptions = { autoplay: false, controls: true, sources: [{ src: '/api/video', type: 'video/mp4' }]}ReactDOM.render( &lt;React.StrictMode&gt; &lt;App {...videoJsOptions}/&gt; &lt;/React.StrictMode&gt;, document.getElementById('root')); Sanic 中处理请求Sanic 提供文件流响应对象，并提供 api 处理请求中的 byte-range。将两者结合，即可构造出一个带 Content-Range 头的响应。 12345678910111213141516from sanic import Sanicfrom sanic.response import file_streamfrom sanic.handlers import ContentRangeHandlerfrom sanic.compat import stat_asyncapp = Sanic('player')app.static('/static', './static')@app.get('/api/video')async def api(request): file_path = './1.mp4' stats = await stat_async(file_path) _range = ContentRangeHandler(request, stats) return await file_stream(file_path, _range=_range) 结论 基本能达到“秒开”效果。 需要媒体格式支持才行。比如 MP4，就需要在其文件开头具有 moov atom 信息。 参考Problems with playback：https://docs.videojs.com/tutorial-troubleshooting.html#problems-with-playback Problems when hosting media：https://docs.videojs.com/tutorial-troubleshooting.html#problems-when-hosting-media Video.js and ReactJS integration：https://docs.videojs.com/tutorial-react.html#react-class-component-example ContentRangeHandler：https://sanic.readthedocs.io/en/stable/sanic/api/core.html#sanic.handlers.ContentRangeHandler 如何优雅地实现网页播放视频：https://www.jianshu.com/p/65af0f01cb97","link":"/React+Videojs+Sanic%E6%89%93%E9%80%A0%E7%AE%80%E6%98%93%E6%B5%81%E6%92%AD%E6%94%BE%E5%99%A8.html"},{"title":"理解 MP4 moov atom","text":"在上一篇关于 Html5 流播放器 的文章中提到，边下载边播放这个功能需要媒体文件的支持。为了能进一步理解这句话的意思，查阅了一些相关资料，整理成文。 MP4 moov atomatom 是 MP4 文件里的一个数据单元，它可以包含关于视频文件的各种信息。 moov atom，即 movie atom，定义了 timescale、duration 以及其它子 atom 信息。 可以想见，若要在视频文件未能被完整下载前即开始播放，并能跳转到指定位置，肯定要首先获知其 moov atom 信息。这也是 moov atom 存在的意义。 解析 MP4 文件中的 moov atom FFmpeg 命令行 Linux 下： 1ffmpeg -v trace -i videofile.mp4 2&gt;&amp;1 | grep -e 'moov' Windows PowerShell： 1.\\ffmpeg.exe -v trace -i videofile.mp4 2&gt;&amp;1 | Select-String 'moov' 输出如下信息： 12345[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7fffd6030080] type:'moov' parent:'root' sz: 620709 229758438 230379139[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7fffd6030080] type:'mvhd' parent:'moov' sz: 108 8 620701[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7fffd6030080] type:'trak' parent:'moov' sz: 272502 116 620701[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7fffd6030080] type:'trak' parent:'moov' sz: 347993 272618 620701[mov,mp4,m4a,3gp,3g2,mj2 @ 0x7fffd6030080] type:'udta' parent:'moov' sz: 98 620611 620701 第一列数字为 atom 字节数，第二列为文件中起始字节数，第三列为结束位置。 如果文件里没有 moov atom，输出为空。 其它工具 MP4creator AtomicParsley 添加 moov atom / 调整 moov atom 位置像上边示例输出显示的那样，一些 MP4 的 moov atom 是放在文件末尾位置的，这起不到想要的作用，必须把它调整到文件开始位置。更甚者，一些 MP4 文件根本没有 moov atom 信息。可以以同样的方法添加。 FFmpeg 命令行 1.\\ffmpeg.exe -i input.mp4 -c copy -map 0 -movflags faststart output.mp4 其它工具 MP4creator MP4FastStart 疑问实测发现，moov atom 在文件末尾的时候，也是能达到边下载边播放效果的。（PC Chrome 93.0.4577.82） 但是会触发三次请求。 第一次： Request：Range: bytes=0- Response：Content-Range: bytes 0-230379138/230379139 第二次： Request：Range: bytes=229736448- Response：Content-Range: bytes 229736448-230379138/230379139 第三次： Request：Range: bytes=32768- Response：Content-Range: bytes 32768-230379138/230379139 神奇的纠错能力，不知道是 Chrome 还是 Video.js 做出的贡献。 参考Movie Atoms：https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html Understanding the MPEG-4 moov atom: Pseudo-Streaming in Mp4：https://sanjeev-pandey.medium.com/understanding-the-mpeg-4-moov-atom-pseudo-streaming-in-mp4-93935e1b9e9a Problems with playback：https://docs.videojs.com/tutorial-troubleshooting.html#problems-with-playback 4.22 mov, mp4, ismv：https://ffmpeg.org/ffmpeg-formats.html#mov_002c-mp4_002c-ismv","link":"/%E7%90%86%E8%A7%A3MP4-moov-atom.html"},{"title":"React + Jsx 多页面配置","text":"多页面用不到 create-react-app，项目结构需要手动配置。 Jsx 不能带到生产环境去，会导致每次加载 js 文件时都要做语法转换，所以需要用 babel 预处理。 项目根目录下，创建 package.json：1npm init -y 把 html 文件放在 src 目录下，js 文件放在 src/js 目录下。html 中引入对应的 js： 1&lt;script src=&quot;/js/index.js&quot;&gt;&lt;/script&gt; 不要加 type=”text/babel”，路径其实对应的是预处理后的、被转换的 js 文件。 https://reactjs.org/docs/add-react-to-a-website.html 安装 babel 命令行：1npm install --save-dev @babel/core @babel/cli https://babeljs.io/docs/en/babel-cli/ 安装 babel React 插件：1npm install --save-dev @babel/preset-react presets 可以放在配置文件里，也可以通过命令行声明。 https://babeljs.io/docs/en/babel-preset-react 通过命令行预处理 jsx：1npx babel --presets @babel/preset-react .\\src\\js\\index.js --out-dir .\\build\\js\\","link":"/React+Jsx%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE.html"},{"title":"2022年我的方向和目标明确了","text":"知新…不出意外的话，这大概是我 2022 年甚至以后很多年里的努力方向。我把今年中大部分的业余时间都付诸于这些新知识的学习和实践上，并从中再一次感受到了学习的乐趣。 系统学习 React.js/Javascript 1. 精读 React.js 官方文档 优先级：高 2. 系统学习 Javascript https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 优先级：中 3. 系统学习 antd 组件库 优先级：低 系统学习 Sanic/Python/后端技术栈 1. 掌握 Sanic 精读 Sanic 用户指南，熟悉框架常用技法。 精读 Sanic API 手册，全面了解框架能力。 优先级：高 2. 通过 Python 文档 熟悉 Python 生态。 现在对于 Python 的了解和应用还仅是停留在简单的脚本编写层级上。若要编写大规模的 Python 代码，比如一个可发布的 Package，就无从下手了。应对 Python 的整体生态有一个认识，而不只是了解语法。 优先级：中 3. 入门 MySQL 应该掌握一门 DBMS，并能了解其特性，其与其它竞品间的优劣，以作有针对性的优化。但是在项目未有瓶颈之前，又显得意义不大，可在时间有余时先做了解，以 ORM 的学习和应用为先。 优先级：低 4. 入门 Tortoise ORM 了解 Tortoise ORM 配合 MySQL 的基本使用方式。 优先级：中 温故…Android/Kotlin不应该全面放弃移动端开发。随着智能家居的演进，Android 的应用领域会更多。 优先级：中 C++继续巩固 C++17 的同时，了解后续标准的动向。但不必花费太多精力，毕竟应用层面来说，新标准的普及还有很长很长一段路。 优先级：低 FFmpeg继续深入学习 FFmpeg，完善 FFCutter 工具。 优先级：低 舍…Unity工作中再用到 Unity 的机会应该很少了；作为兴趣深入学习的性价比又太低——毕竟跨度太大，游戏领域的门槛又高——索性放弃，将时间用于收益更高的地方。 领域…智能家居我长期、无限看好的一个领域。2022 年终于有机会规模化地实践了。持续完善 SmartHome 系统。满足自用的基础上，争取将其像 HomeAssistant 一样可配置化，贡献到社区中，供更多人选用。","link":"/2022%E5%B9%B4%E6%88%91%E7%9A%84%E6%96%B9%E5%90%91%E5%92%8C%E7%9B%AE%E6%A0%87%E6%98%8E%E7%A1%AE%E4%BA%86.html"},{"title":"智能家居实施状况汇总","text":"12 月 11 号那天把宽带移到了新家，终于可以将我的智能家居想法正式实施了。 网络布线弱电箱在玄关鞋柜里边，我把电信光猫改了桥接直接放弱电箱里了。中海预先布了 5 条线，两条六类，三条超五类，都可以支持千兆，省了从弱电箱到客厅重新布线的麻烦。 但是书房居然没有布线。这就很麻烦，因为我的台式机、NAS 等一些常用的有线设备肯定要放书房的啊。300M 的宽带从客厅跨过三道墙进入书房后，实测无线网的网速只剩下将将 100M 了。拿另一台路由器做无线 Mesh，发现不管放哪儿，网速甚至都提不到 200M。 无奈还是要做有线 Mesh，另一台路由器直接放到了书房里。网线就扔地上，经过的走廊说服了我老婆铺上地毯。网线是那种扁平的，恰好以这种温馨的家居设计遮盖了丑陋的外露网线，还不影响走动。 有了书房的路由做中继，实测在主卧的 WIFI 网速也有 200M 了，完全满足偶尔在床上看看电影的需求。 智能设备选购市场越来越大，也越来越乱了。除了米家、涂鸦、天猫精灵、欧瑞博这几个开放型的智能平台，现在是个电器生产厂家都在做自己的智能家居平台了，什么海尔格力美的华为。百花齐放对智能家居产业当然是好事，说明大家对此领域的广阔前景有共同的认知。 但是太缺少标准化的规范了。且不说 WIFI、蓝牙、Zigbee 这种争论已久的网络传输层面上的分歧，只关注 WIFI 实现的话，其市场乱象也已经到了人所不能忍的地步了。生产厂家仿佛看到了新的护城河，纷纷实现各不相容的数据结构跟协议。又有何用呢？“智能”两字只是对已有硬件功能的延展，并没有催生出突破性的新功能。假如全行业采取统一规范的数据结构和协议，反而能让生产厂家们更聚焦于硬件能力的提升。 唉，瞎啰嗦了几句。但是现状已经支离破碎，只有去适应了。 所以大原则还是我之前的思路，小米系和 HA 系。使用量够大，且是开放甚至是开源的方案，经过社区验证过，实施起来能节省很多时间。 截止目前，选购了如下智能单品： 绿米 A1 电动窗帘轨道电机 x 3，双十一总价 1584.15。 小米米家鎏金版空调2匹挂机 x 1，2999。 美的 酷金/大1匹变频空调冷暖家用挂机智能空调 x 3，双十一总价约 6300。 可惜中海免费送了一套西顿的灯具，惹得我老婆不同意换掉这些便宜货。所以灯光相关的智能化场景只能等以后再说了。 SmartHomeSmartHome 是我自己设计的一套 B/S 结构的智能家居控制系统。灵感来自于 HomeAssistant，HA 是一个开源的家居自动化解决方案，其 puts local control and privacy first 的理念我深感赞同。所以，SmartHome 也同 HA 一样，仅支持部署在设备所在局域网内。我现在用的是一块树莓派 3B 做主机，稳定性良好，暂时没有发现问题。 如图，SmartHome 前端采用 React.js 框架实现，后端通过 Sanic.py 框架实现，设备配置存储在 devices.json 文件里。 devices.json偷懒把所有设备描述都塞到了一个文件里（前期开发聚焦在前后端的开发上），形成了一个 devices 数组，数组中的一个对象即是一个设备。 设备必需属性 name：设备名称，可以显示到前端界面上。 protocol：设备所用协议，现在仅支持 “miot”：小米，”midea”：美的。协议的不同决定了设备会有一些厂商特有的属性，比如美的需要额外的 id 和 key 用于授权。 ip：设备的本地 IP。 ui：显示用的设备图标。 x：图标 x 坐标 y：图标 y 坐标 width：图标宽 height：图标高 properties：设备属性集 属性对象又有如下一些必需的属性： name：属性名称，显示用 type：属性值类型，支持 “bool”、”radio”、”range”、”range+”、”text”、”rgb”。 id：属性 id。对 miot 类型设备，id 是通过 siid 和 piid 合成而来的，仅具有 SmartHome 业务之用；但是对 midea 设备，id 值是需要拿来调用其协议库的，不能随意更改。 value：属性值。可以不在 devices.json 文件内声明，后端会自动以最新值赋值并传递给前端。 设备高级属性 timers：预设一组定时器，在到达指定时间时批量应用指定设备属性值。定时器基于 APScheduler 库实现，采用与其相同的属性描述，从而可以透传定时器参数到 APScheduler 接口。 scenes：预设一组场景，选中时批量应用指定设备属性值。 server.py功能还比较简单，仅有两个 API： @app.get('/model/init') 获取所有设备当前状态，以 json 格式返回。 @app.post('/') 更新设备属性。 request 消息体格式： 1234567{ &quot;ip&quot;: ... &quot;value&quot;: ... &quot;id&quot;: ... // for midea &quot;siid&quot;: ... // for miot &quot;piid&quot;: ... // for miot} 路由函数会借机重新获取所有设备的最新状态并通过 response 通知到前端，效果同 /model/init。 这里可能会跟后续的 devices.json 拆分改造一起做下优化，仅返回 request 标识设备的最新状态。至于通过其它终端所做的修改，会通过 websocket 广播到所有终端。 前端搭配 AntD，实现了三层的组件结构： &lt;SmartHome /&gt; 唯一，挂在 &lt;App /&gt; 下边。除了负责渲染设备外，SmartHome 还使用 svg 渲染了一个户型图作为背景图。将设备图标显示在户型图的合适位置，就可以“按图索骥”了。 &lt;SmartDevice /&gt; 其实是一个 antd.Modal。当点击某个设备图标时，SmartDevice 会以此设备属性动态渲染并显示。","link":"/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%AE%9E%E6%96%BD%E7%8A%B6%E5%86%B5%E6%B1%87%E6%80%BB.html"},{"title":"Videojs 全屏时显示弹幕和发送框","text":"Video.js 版本：7.10.2 弹幕库：https://github.com/weizhenye/Danmaku，2.0.2 版本 因为实现方式比较不规范，会深入 Video.js 内部 dom 进行操作，不确定是否适用其它版本。 全屏弹幕我使用 vjs 的姿势是这样的： 123&lt;div id=&quot;danmaku-container&quot; ref={danmakuContainerRef} divdata-vjs-player&gt; &lt;video ref={videoRef} className=&quot;video-js vjs-big-play-centered&quot; /&gt;&lt;/div&gt; 运行时发现它会展开成如下 dom 结构： 可以看到，video 还有其它 vjs 组件比如 vjs-control-bar（控制条）都放在了 vjs_video_3 这个 div 下边。vjs 会操作这个 vjs_video_3，给它增删几个 class， 实现 video 全屏/非全屏的切换。 我第一次尝试时，是直接将 danmaku-container 作为弹幕的容器传递给弹幕库的，即弹幕 div 是 danmaku-container 的最后一个子元素。但是全屏时就看不见弹幕了，我尝试调整弹幕的 z-index，不起作用。这个问题到现在还没搞懂。 但是我发现，同样是 div 实现，控制条就可以总是显示在视频的上层。所以我尝试将弹幕放在跟 vjs-control-bar 同层： 1234danmakuRef.current = new Danmaku({ // 不通过 vjs_video_3 名字获取元素，增加通用性 container: danmakuContainerRef.current.firstElementChild}); danmaku-container 的 firstElementChild 也就是 vjs_video_3 了。 Okay，全屏时也可以看到弹幕了。但是 vjs_video_3 尺寸变化时没有通知到弹幕 div，这个需要自己处理： 12345new ResizeObserver(entries =&gt; { if (danmakuRef.current) { danmakuRef.current.resize(); }}).observe(videoElement); videoElement 是 video 的对象，换成 vjs_video_3 应该也是一样的。resize() 是我用的弹幕库的接口方法，按构造时传入的容器尺寸自动计算新尺寸，省了自己传递参数。 好了！不需要调整 position 乱七八糟，到这里弹幕的显示就已经完美了。 发送框显示在视频之上vjs 支持扩展 vjs-control-bar。vjs-control-bar 里有一个 vjs-custom-control-spacer 组件，可以将自己的 UI 填充到里边。但问题是控制条总共就那么宽，如果过多自定义 UI 的话，势必显得很拥挤。 所以还是基于弹幕显示的原理，组合好发送 UI 之后，把最外层的 div 添加到 vjs_video_3，这种实现方式的自由度最高：可以自定义任何尺寸和位置： 12345div.style.position = &quot;absolute&quot;;div.style.width = `${INPUT_DIV_WIDTH}px`;div.style.height = `${INPUT_DIV_HEIGHT}px`;div.style.left = `${(videoRef.current.offsetWidth-INPUT_DIV_WIDTH)/2}px`;div.style.top = `${videoRef.current.offsetHeight-INPUT_DIV_HEIGHT}px`; 我折腾的过程中发现，vjs 同样是通过操作 vjs_video_3 的 css 类实现控制条的显示/隐藏的： 123456789101112// @see https://github.com/videojs/video.js/blob/main/src/js/player.jsif (this.userActive_) { this.userActivity_ = true; this.removeClass('vjs-user-inactive'); this.addClass('vjs-user-active'); /** * @event Player#useractive * @type {EventTarget~Event} */ this.trigger('useractive'); return;} vjs 没有直接引用控制条的 dom 对象，而是通过动态生成后代选择器控制控制条的显示/隐藏： 123456789101112.vjs-has-started.vjs-user-inactive.vjs-playing .vjs-control-bar { visibility: visible; opacity: 0; transition: visibility 1s, opacity 1s;}.vjs-has-started .vjs-control-bar { display: flex; visibility: visible; opacity: 1; transition: visibility 0.1s, opacity 0.1s;} 这个信息有大用，因为我可以将我发送框 div 的类名指定为 vjs-control-bar，这样，输入框的显示/隐藏就可以跟控制条保持一致了！不需要再自己写控制逻辑了！ web 真好玩~","link":"/Videojs%E5%85%A8%E5%B1%8F%E6%97%B6%E6%98%BE%E7%A4%BA%E5%BC%B9%E5%B9%95%E5%92%8C%E5%8F%91%E9%80%81%E6%A1%86.html"},{"title":"Webpack 打包 React 组件","text":"之前 通过直接运行 babel 相关命令，把 jsx 语法做了预处理。但输出远远达不到 create-react-app 的水平。 Google 了一圈发现，原来可以通过 webpack 把 jsx 预处理、js 压缩、js 打包几个步骤一次性执行。 初始化 Webpack Config安装 webpack： 1npm i webpack webpack-cli 在项目根目录（package.json 所在目录）下新建 webpack.config.js 文件，这个是 webpack 配置文件，写入以下内容： 123456789const path = require('path')module.exports = { entry: path.resolve(__dirname, 'src', 'index.js'), output: { path: path.resolve(__dirname, 'dist'), filename: 'index.min.js' }} entry 是一个入口点。标识 webpack 开始创建其内部依赖图所用的 js 文件。webpack 可以计算出入口文件所依赖的其它模块和库。 output 告诉 webpack 打包后的文件名字和存放路径。 这时候的 webpack 配置就可以处理非 jsx 编写的 React 文件了。 执行 webpack： 1npx webpack --config webpack.config.js 在 dist 目录下就会看到 index.min.js 文件了。文件内容跟 create-react-app 输出类似。 添加 babel 相关配置以预处理 jsxwebpack 只能理解标准的 js 和 json 文件，像 jsx 这种写法就必须先通过执行一个特定的 loader，将 jsx 转换成标准 js 语法才行。 安装 babel： 1npm i @babel/core @babel/preset-env @babel/preset-react babel-loader 更新 webpack.config.js 文件： 1234567891011121314151617181920212223242526272829const path = require('path')module.exports = { entry: path.resolve(__dirname, 'src', 'index.js'), output: { path: path.resolve(__dirname, 'dist'), filename: 'index.min.js' }, module: { rules: [ { test: /\\.(jsx|js)$/, include: path.resolve(__dirname, 'src'), exclude: /node_modules/, use: [{ loader: 'babel-loader', options: { presets: [ ['@babel/preset-env', { &quot;targets&quot;: &quot;defaults&quot; }], '@babel/preset-react' ] } }] } ] }} 添加了一个 module，制定了一条 rule。 test 表示可通过此规则测试的文件类型； include 指向要进行测试的文件的所在目录； exclude 表示不需要测试的路径； use 表示将对通过测试的文件所应用的动作； loader 即预处理器，这里的 babel-loader 会把 jsx 转换成标准 js； @babel/preset-env 预设检查常用浏览器的兼容性和 polyfill； @babel/preset-react 预设实际执行 jsx 转换。 这时候的 webpack 配置，就可以正确打包使用 jsx 编写的 React 组件了。 后记 webpack 配置文件可以有多个。一个非 SPA 的网站可以一个页面对应一个 webpack 配置文件； webpack 还可以打包 css：https://hashinteractive.com/blog/complete-guide-to-webpack-configuration-for-react/#minicssextractplugin 参考 webpack documentation：https://webpack.js.org/concepts/ COMPLETE GUIDE TO WEBPACK CONFIGURATION FOR REACT：https://hashinteractive.com/blog/complete-guide-to-webpack-configuration-for-react/","link":"/Webpack%E6%89%93%E5%8C%85React%E7%BB%84%E4%BB%B6.html"},{"title":"HOPL4 笔记 1-5","text":"HOPL 是 History of Programming Languages（编程语言历史）的缩写，是 ACM 旗下的一个会议，约每十五年举办一次。这是我父的第三篇 HOPL 论文，发表于 2021 年。中文译本 出自 Boolan 之手，不胜感激。 1. 前言 有一种流传广泛的谬见，就是程序员希望他们的语言是简单的。 当你不得不学习一门新的语言、不得不设计一门编程课程、或是在学术论文中描述一门语言时，追求简单显然是实情。 对于这样的用途，让语言干净地体现一些明确的原则是一个明显的优势，也是理想情况。 当开发人员的焦点从学习转移到交付和维护重要的应用程序时，他们的需求从简单转移到全面的支持、稳定性（兼容性）和熟悉度。人们总是混淆熟悉度和简单，如果可以选择的话，他们更倾向于熟悉度而不是简单。 这也是我在前有 C 后有 Rust 的情况下继续跟踪并学习 C++ 新标准的原因：已经上了贼船了，没办法。 任务库 [Stroustrup 1985a,c] 是一个基于协程的库，支持事件驱动的仿真（例如随机数生成），与替代方案相比是非常高效的，甚至可以运行在很小的计算机上。例如，我在 256KB 的内存中运行了 700 个任务的仿真。任务库在 C++ 早期非常重要，是贝尔实验室和其他地方许多重要应用的基础。然而，它有点丑陋，并且不容易移植到 Sun 的 SPARC 体系结构，因此大多数 1989 年以后的实现都不支持它。2020年，协程才刚刚回归。 我父在 1979 年设计 C++ 时实现了两个库：task（协程）和用宏参数化的 vector。虽然在标准化过程中删的删改的改，也足见其个人高雅的技术品味。41 年后，笨重老朽的标委会终于准入了协程…… 2. 背景：C++ 的 1979–2006 我的办公室就在 Dennis Ritchie 和 Brian Kernighan 走廊对面。 贝尔实验室就是万神殿！后来桃李半导体天下的仙童也是出自贝尔，“软硬兼施”。一百年过去了，我们的贝尔在哪里？ 最初我实现的是一个预处理器，它将“带类的 C” 差不多逐行翻译成 C。1982 年，在“带类的 C”的用户数量增长到了几十人的时候，这种方法已经显得无法把控了。所以我写了一个传统的编译器，叫作 Cfront，1983 年 10 月第一次给别人使用。 原来我父也挺会“对付”的，用语法糖验证了 C++ 的技术可行性和市场接受度后才开始考虑专属编译器的问题。嘿嘿，学到了。1979.4 月开始，4 年半后才实现了第一个编译器。基础设施的建设实属不易啊。向流浪地球致敬，在现在这种浮躁的环境下迈出了扎实的一步。游戏科学加油啊…… 直到今天，我仍然认为构造函数和析构函数是 C++ 的真正核心。 不要陷入对完美的徒劳追求。 不管是业务开发、架构设计，同样适用。 应取消预处理器的使用。 我父有点飘了……虽然后来的模版取代了一部分宏的能力，但是因为一直没有静态反射机制，# 和 ## 依然是逆天的存在。 不要给 C++ 以下的低级语言留有余地（汇编语言除外）。 嘿嘿嘿，我父前边才说完“过于狭隘的 C 和 C++ 爱好者之间偶尔会恶语相向”，你这条设计规则才是祸根吧…… 1984 年：运算符和函数重载——除了算法和逻辑运算符外，还包括：允许用户定义 =（赋值）、()（调用；支持函数对象）、[]（下标访问）和 -&gt;（智能指针）。 前些天面了一小伙，居然函数对象的概念都没听过。我连换仿函数、functor 几个叫法，生怕是因为翻译问题。父啊，你的伟作现在就这样被人糟蹋呢…… 我从未使用过“C++ 是一种面向对象的编程语言”这种说法，这件事很多人并不知道，或者因为感到有些尴尬而有意忽略了。那时候，我的标准描述是 C++ 是一门偏向系统编程的通用编程语言，它是 更好的 C 支持数据抽象 支持面向对象编程 支持泛型编程 这个说法过去和现在都是准确的，但不如“万物皆对象”这样的口号令人兴奋！ “视 C++ 为一个语言联邦”。OOP 或 TMP，没有高低之分。 经过了惯例性的、大约十年的工作，该委员会终于发布了第一个标准：C++98。我和许多其他人自然更愿意更快地输出一个标准，但是委员会规则、过度的雄心和各种各样的延迟使我们在时间表方面与 Fortran、C 和其他正式标准化的语言站在了同一起跑线上。 1989.12 月 ANSI C++ 标委会就已经成立，十年的时间啊，你们在搞什么？ dynamic_cast 是一个运行期操作，依赖于存储在 Shape 的虚拟函数表中的数据。它通用、易用，并且与其他语言类似的功能一样高效。然而，dynamic_cast 变得非常不受欢迎，因为它的实现往往是复杂的，特殊情况下手动编码可能更高效（可以说这导致 dynamic_cast 违反了零开销原则）。 是的。有层次的、设计良好的架构中，两个具体的实现子类往往是精确的一对一关系，这种良好的设计保证了在最上层的实现类中执行静态类型转换总是安全的，不需要运行时检查。 3. C++ 标准委员会 SG4 网络，目前处于休眠状态，因为其结果正在等待被合并到标准中。 三年又三年……到现在都还没有 executor 被批准进入 C++23 的消息，networking 那就更无望了。结合 C++11 之后两个补丁版本的更新内容看，2026 年能上线 networking 就不错了。 网络（15 年，仍在进行中） 15年，错过了 web2.0，错过了移动互联，错过了异步模型…… 我注意到，2018 年秋天的会前邮件（新论文汇总）的字数是莎士比亚全集的三倍。 我之前抨击过，无端造出许多没有任何表征的讳莫高深的概念，然后又用大幅文字去定义、解释。最近几年，JavaScript 近乎以一年一版本的频率大幅更新；Python 也仅用了 10 年左右时间完成了 Python2 到 Python3 的完全过渡，甚至将 Python3 迭代到了 Python3.10。我也真纳闷，标委会的老爷们你们是怎么沉得住气的？！ 我从温斯顿·丘吉尔的格言中得到些许安慰，“民主是最糟糕的政府形式，除了所有那些人类一再尝试过的其他形式”。 悔之晚矣…… 4. C++11：感觉像是门新语言 直到 2018 年，我仍能看到 C++98 前的编译器被用于教学。我认为这是对学生的虐待，剥夺了他们接触学习我们 20 多年的进展的机会。 我的面试经历则给了我不同的感受：应届生们对 C++11 后的新标准的掌握程度普遍好于已工作多年的程序员。这算不算是一种自虐？ 即使有了 C++11 的支持，我仍然认为无锁编程是专家级的工作。 我至今没有、可预见的未来也不会了解的几个 C++ 知识点之一。 我曾希望这会产生一个由线程池支持的工作窃取（work-stealing）的实现，但我还是失望了。 我父有些过分的仁慈、民主了。这么一个被普遍应用的技术方案，最后还是跟随了标委会的意愿。 我早在 1982/83 年冬天就实现了 auto，但是后来为了保持 C 兼容性而不得不移除了这一特性。 我父太难了…………既要对标委会妥协，又要为了市场份额不得不跟 C 保持双向兼容。 直到后来（大约从 2015 年开始），constexpr 函数才成为元编程的主要支柱。C++14 允许在 constexpr 函数中使用局部变量，从而支持了循环；在此之前，它们必须是纯函数式的。C++20（最终，在首次提出后约 10 年）允许将字面类型用作值模板参数类型 [Maurer 2012]。因此，C++20 将非常接近最初的目标（1979 年），即在可以使用内建类型的地方也都可以使用用户定义的类型。 关于 constexpr 的讨论是有史以来最激烈、最不愉快的。 lambda 表达式的实现基本上是编译器构建一个合适的函数对象并传递它。 变参模板的缺点是容易导致代码膨胀，因为 N 个参数意味着模板的 N 次实例化。 有些实现技巧实属“黑魔法”，不应当暴露给非专家。大部分程序员可以愉快地编写多年好的 C++ 代码，而不用了解这些复杂手段和神秘技巧。遗憾的是，初学者们一拥而上去研究这些最可怕的特殊代码，并从给别人（经常是错误地）解释它们的过程中得到巨大的自豪感。博主和演讲者们通过显摆令人提心吊胆的例子抬高他们的名望。这是 C++ 语言复杂性名声的一个主要来源。 面试没必要太刁。 random 库提供了分布函数和随机数产生器，其复杂性被誉为“每个随机数库都想长成的样子”。但它对初学者或者一般用户（常需要随机数）并不易用。（此处省略原文……） 相比之下，Howard Hinnant 的 chrono 库 [Hinnant et al. 2008] 处理时间点和时间间隔，在提供复杂功能的同时仍保持了易用性。 是的！两个库都用过，体验天差地别。 5. C++14：完成 C++11 5.1 数字分隔符 12auto a = 1'234'567; // 1234567（整数）auto b = 1'234'567s; // 1234567 秒 5.2 变量模板 2012 年，Gabriel Dos Reis 提议扩展模板机制，在模板类、函数和别名 [Dos Reis 2012] 之外加入模板变量。例如： 12template&lt;typename T&gt;constexpr T pi = T(3.1415926535897932385); 5.3 函数返回类型推导 12template&lt;typename T&gt;auto size(const T&amp; a) { return a.size(); } 5.4 泛型 lambda 表达式 1auto get_size = [](auto&amp; m){ return m.size(); }; 5.5 constexpr 函数中的局部变量 允许使用局部变量和 for 循环。 12345678910constexpr int min(std::initializer_list&lt;int&gt; xs){ int low = std::numeric_limits&lt;int&gt;::max(); for (int x : xs) if (x &lt; low) low = x; return low;}constexpr int m = min({1,3,2,4});","link":"/HOPL4%E7%AC%94%E8%AE%B01-5.html"},{"title":"HOPL4 笔记 6","text":"HOPL 是 History of Programming Languages（编程语言历史）的缩写，是 ACM 旗下的一个会议，约每十五年举办一次。这是我父的第三篇 HOPL 论文，发表于 2021 年。中文译本 出自 Boolan 之手，不胜感激。 Concepts—我父最大的执念，也算是我父的滑铁卢了吧……大约是十年前吧，就看过我父亲自上阵“路演” Concepts 主题的 PPT。念念不忘，必有回响。终于还是标准化了。这是一篇夹在 C++14 和 C++17 时间线中间的大幅文章，远不到 C++20 内容出场的时候，可见我父的急不可耐…… 我的看法？我是一个反模版者（注意不是反泛化），语法笨重，强制的实现可见，乱七八糟的错误信息。一群四六不懂的 TMP 至高无上鼓吹者直接让我把这种理性的反对变成了冲动的反感。所以这么些年我都没怎么系统地学习过模版。 Concepts 当然是出于善意，能解决“乱七八糟的错误信息”问题，在正向使用模版的时候也能对编译器做出正确的指示。但是！不管是优柔寡断或是市场的原因，引入新特性的同时依然保留了旧的、坏的实现路径，恰恰是我父前文提到的 N+1 问题：为了解决前边 N 种方案存在的问题引入了第 N+1 种方案。隔代的 C++ 程序员们该怎么沟通、共事？（此刻，我突然理解了那些依然坚持使用 C++98 的程序员们。）而且 Concepts 引入的长长的前缀语法抵消了 auto 所做的简化努力，语法笨重的问题反弹了。 为时晚矣……模版依然是特定人群（专家？）、特定领域（开源？）的小众选择。 6. 概念 精确指定并检查一个模板对于参数的要求曾经是 C++0x 的最出彩之处，会对泛型编程提供关键支持。可是，它最终甚至没能进入 C++17。 概念是简化泛型编程的宏伟计划的一部分。 因为这一点经常被忽视，我必须强调，概念是谓词，它们不是类或类层次结构。 6.3.6 改进 在 Concepts TS 工作的初期，一个 concept 是一个返回 bool 值的 constexpr 函数。 123// 函数风格：template&lt;typename T&gt;concept bool Sequence() { return Has_begin&lt;T&gt;() &amp;&amp; Has_end&lt;T&gt;(); } 然后 Gabriel Dos Reis 将变量模板引入到 C++14（§5.2）中。 123// 表达式风格：template&lt;typename T&gt;concept bool Sequence = Has_begin&lt;T&gt; &amp;&amp; Has_end&lt;T&gt;; 删除 bool 是 Richard Smith 提出的一系列改进建议的一部分 123// 表达式风格：template&lt;typename T&gt;concept Sequence = Has_begin&lt;T&gt; &amp;&amp; Has_end&lt;T&gt;; 6.3.7 等效语法 Concepts TS 支持在函数声明中使用概念的三种表示法： 为通用起见，显式使用 requires 语句 1template&lt;typename S&gt; requires Sortable&lt;S&gt; void sort(S&amp;); 简写表示法，用于表示类型的类型 1template&lt;Sortable S&gt; void sort(S&amp;); // 简写表示法 自然表示法（也称为简短表示法、常规表示法等） 1void sort(Sortable &amp;); // 自然表示法 自然表示法成为强烈反对概念的焦点。我——还有其他人——坚持这种优雅的表达…………我们看到（过去和现在）这是有用而优雅的一步，可以使泛型编程逐渐变成一种普通的编程方式，而不是一种具有不同语法、不同源代码组织偏好（“仅头文件”）和不同编码风格（例如模板元编程）的暗黑艺术。 精准的命中 C++ 模版范式的死穴啊！ 我也很确定，我的目标是使泛型编程尽可能地像“普通”编程，但这不是普遍共识。仍然有人认为，泛型编程超出了绝大部分程序员的能力。但我没有看到任何证据。 是现状无端形成了一道非必要的技术壁垒，导致绝大部分程序员远离了模版；而非泛型本身。“有人”在故意将因果倒置。 投票结果依然对我们不利：25 票赞成，31 票反对，8 票弃权。我的解释是，用户投了赞成票，语言技术人员投了反对票，但这可能会被认为是酸葡萄吧。 Concepts 被投票踢出了 C++17，我父急了…… 6.4 C++20 概念 自然表示法（例如 void sort(Sortable&amp;);）因有争议而被排除在外。 我父怂了，折中出了一个“丑八怪”方案： 使用 auto 来识别使用自然表达式的模板参数，例如 void f(Concept auto&amp;); 1234// 几乎自然的表达式：void sort(Sortable auto&amp; x); // x 必须 SortableIntegral auto ch = f(val); // f(val) 的结果必须为 IntegralIntegral auto add(Integral auto x, Integral auto x); // 能用一个宽类型来防止溢出 为了能让用户感知到 Concepts 和 Template，在概念名称和变量中间插入了一个 auto，以区别于非模版代码…… “自然表达式”已重命名为“缩写语法”，虽然它不仅仅是一个缩写。 延迟很多年才引入概念造成了长期的伤害。基于特征（traits）和 enable_if 的临时设计数量激增。一代程序员在低级的、无类型的元编程中成长起来。 泪目，我父深知我心……我对模版所有的思考都化作了文章开头的引言，居然如此契合我父的心意，不枉我学之、用之、思之、信之。","link":"/HOPL4%E7%AC%94%E8%AE%B06.html"},{"title":"HOPL4 笔记 7—11","text":"HOPL 是 History of Programming Languages（编程语言历史）的缩写，是 ACM 旗下的一个会议，约每十五年举办一次。这是我父的第三篇 HOPL 论文，发表于 2021 年。中文译本 出自 Boolan 之手，不胜感激。 7. 错误处理 使用包含 (值,错误码) 对的类会带来巨大的成本。除了检测错误码的成本外，许多 ABI（应用程序二进制接口）甚至不使用寄存器来传递小的结构体，所以 (值,错误码) 对不仅传递了更多的信息（是通常数量的两倍），而且也使传递的性能有数量级的降低。可悲的是，在许多 ABI 中，尤其那些针对嵌入式系统的 ABI（专为 C 代码设计），这个问题直到今天（2020 年）依然存在。 这些年来，异常处理的性能相对较慢，是因为我们在优化非异常方面花费了大量精力。 具有讽刺意味的是，那些坚定支持异常规约的人转而去帮助设计 Java 了。 一些人相信那些关于异常机制的基于最坏情况和/或不切实际的比较的低效传闻，例如…………，或者使用异常来做简单的错误处理，而不是把异常用于无法在本地处理的错误。 基础库的作者对多种错误处理方案的问题感受最为深刻。他们不知道他们的用户喜欢什么，他们的用户可能有很多不同的偏好。C++17 文件系统库的作者们选择了把接口重复一遍：对于每个操作，他们提供两个函数，一个在错误的情况下抛出异常，另一个函数则通过设置标准库的 error_code 参数将错误码通过参数传递出来 在异常抛出与其处理程序之间的路径上的 noexcept，会把一个异常变成程序终止运行。 异常被添加到 C++ 中的一个重要原因是为了支持那些在发生错误时也决不可以无条件中止的应用。异常仅表示发生了故障，并且从 main() 到抛出点的路径上的任何代码都可以对其进行处理。 我父基本把异常的不适用场景总结出来了：简单的错误处理、严重到可以无条件中止应用的错误发生时。 从根本上讲，我认为 C++ 需要两种错误处理机制： 异常——罕见的错误或直接调用者无法处理的错误。 错误码——错误码表示可以由直接调用者处理的错误（通常隐藏在易于使用的检测操作中或作为 (值,错误码) 对从函数返回）。 在理想情况下，应该只有两种错误处理的方法，但是我真的不知道如何达到这样一种理想状态。 我要问一个简单而潜在有用的问题：“一个错误要多罕见才被看作是异常情况”？不幸的是，答案是“这要看情况”。这取决于代码、硬件、优化器、异常处理的实现，等等等等。 空间占用问题可能比运行期问题更难解决。 错误码 or 异常，我父也没办法给出准确选择标准的一个问题。只能以简单、罕见、看情况这些宽泛定义的词汇做一个宏观上的总结。所以 Google 编码规范中一刀切地禁止使用异常就可以理解了。 8. C++17：大海迷航 C++17 有很多新的特性，但没有一个我认为称得上重大。 而我却学得很嗨。我父的理由是：“尽管我也喜欢 C++17 中的某些功能，但令人困扰的是这些功能没有统一的主题，没有整体的规划，似乎只是由于可以达到投票多数而被扔进语言和标准库中的一组“聪明的想法””。这就是架构师跟程序员的区别吧？ 8.1 构造函数模板参数推导 1shared_lock lck {m}; // 不需要显式写出锁类型 8.2 结构化绑定 我认为在当前的 C++ 中，tuple 有点被过度使用了，当多个值并不互相独立的时候，我倾向于使用明确定义的类型 我会 using MyType = tuple&lt;int, string, others...&gt; 这样折中一下。 我指出结构化绑定应该引入零开销别名，而任何意味着表示变化的类型转换将导致显著的开销。 是的，对任何可能的（不是全部，比如数组）绑定，都是通过 using 别名实现的，真正的零开销！ 最初的提案使用花括号（{}）来聚合引入的名字…………然而一些成员，如 Chandler Carruth 和 David Vandevoorde，怕语法上会有歧义，而坚持认为这样会令人困惑，“因为 {} 代表作用域”。所以我们有了 [] 语法………… 这是个小改动，但我认为是个错误。这个最后一刻的改动，导致了属性表达语法的小小复杂化（比如 [[fallthrough]]）。 这明显站不住脚嘛，统一初始化不就已经拓展了 {} 的用法。 8.3 variant、optional 和 any 不幸的是，这三种类型的设计被分开讨论，好像它们的使用情况毫不相干一样。相对于标准库而言，直接语言支持的可能性似乎从未被认真考虑。 导致的结果就是： 1234567optional&lt;int&gt; var1 = 7;variant&lt;int,string&gt; var2 = 7;any var3 = 7;auto x1 = *var1 ; // 对 optional 解引用auto x2 = get&lt;int&gt;(var2); // 像访问 tuple 一样访问 variantauto x3 = any_cast&lt;int&gt;(var3); // 转换 any 三种截然不同的取值方式…… 我认为这三种可辨识 union 的变体只是权宜之计。要解决 union 的问题，函数式编程风格的模式匹配更优雅、通用，潜在也更为高效。…………我们的目的是消除对访问者模式的使用 [Gamma et al. 1994]。 8.4 并发 scoped_lock——获取任意数量的锁，而不会造成死锁 shared_mutex 和 shared_lock——实现读写锁 有时，我同很多 C++ 程序员一样在想，“是什么让他们花了这么长时间？” 他们——标委会的老爷们。 8.5 并行 STL 不出意外，委员会中有一些反对的声音，大多数来自于希望为专家级用户提供复杂接口的人。 我十分怀疑这些人都是别的语言阵营派来的奸细。 将来我们会看到专门为并行使用而设计的算法。这正在 C++20 中变为现实。 另一个弱点是，仍然没有取消一个线程的标准方法。例如，在搜索中找到一个对象后，一个线程不能停止其他正在并行执行的搜索。 C++17 的并行算法也支持向量化。这很重要，因为对 SIMD 的优化支持是硬件在单线程性能方面仍然（2017 年后）有巨大增长的少数领域之一。 8.8.3 统一调用语法 回头看，我认为面向对象的写法（如 x.f(y)）压根就不该被引入。传统的数学式写法 f(x,y) 就足够了。 坏了……要转向函数范式了？ 9. C++20：方向之争 令人震惊的是，C++ 并没有关于动态链接库的标准，也没有标准化的构建系统。 这绝对是阻碍 C++ 生态发展的一个重要阻力。 await 设计无栈、不对称且需要语言支持，而源自 Boost 的设计则使用栈、具有对称控制原语且基于库。无栈协程只能在其自身函数体中挂起，而不能从其调用的函数中挂起。这样，挂起仅涉及保存单个栈帧（“协程状态”），而不是保存整个栈。对于性能而言，这是一个巨大的优势。 我已经等了近 30 年的时间让协程重新回到 C++ 中，我可不想等待一个可能永远不会到来的突破：“最好是好的敌人。” C++ 程序员必须学会限制编译期计算和元编程的使用，只有在值得为了代码紧凑性和运行期性能而引入它们的地方才使用。 像在 Unix 中一样，管道运算符 | 将其左操作数的输出作为输入传递到其右操作数（例如 A|B 表示 B(A)）。 越界访问，有时也称为缓冲区溢出，从 C 的时代以来就一直是一个严重的问题。 1990 年，Dennis Ritchie 向 C 标准委员会提议：“‘胖指针’，它的表示中包括了内存空间以存放运行期可调整的边界。”[Ritchie 1990]。由于各种原因，C 标准委员会没有通过这个提案。在当时，我听到一条极可笑的评论：“Dennis 不是 C 的专家；他从不来参加会议。 哈哈哈……想起了 G 神“I Wrote Python”的段子。 无符号数并不以自然数为模型：无符号数使用模算数，包括减法。比如，如果 ch 是个 unsigned char，ch+100 将永远不会溢出。 我担心的是晦涩难懂的新特性的数量之大会造成危害 [Stroustrup 2018d]。对于非专家来说，它们使得语言变得更加难以学习，代码更加难以理解。 是的……增量学习新标准里的种种语言特性和库特性已经是挑战了，对需要从头学习的新手来说无疑是难上加难。 很多特性具有特殊用途，有些是“专家专用”。不过，有的人总是领会不到，一个对某些人有某种好处的特性，对于 C++ 整体可能是个净负债。 多年来，Bloomberg（那家纽约市的金融信息公司）一直使用一个名为“契约”的实时断言系统去捕获代码中的问题。 新闻界有名的彭博社还是个“技术控”。他们的开源 C++ 库 BDE 被收录在了 cppreference ，我父提到的契约（Contract）就包含其中。 2013 年，一个研究“反射”的研究组（SG7）成立了，…………类似这样的东西很可能会在 C++23 或 C++26 中成为标准。 怪不得我父前文说要彻底消灭预编译宏呢。 10. 2020 年的 C++ 所有迹象表明，自 2015 年以来，C++ 的用户数量和使用领域一直在稳步增长。 多亏了 C++11，及时挽回了 C++ 的颓势。这点我父在前文也提到了。 与大多数编程语言社区相比，C++ 社区一向是出奇地无组织和分散。这个问题早已有之，因为我就没有建立组织的才能。 isocpp.org——C++ 基金会的网站，其中包含与 C++ 有关的新闻，标准化进程相关的信息，以及有用的链接。 cppreference.com——出色的在线参考资料；它甚至有一个历史部分！ 好的软件对我们的文明至关重要。 Qt 依赖于元对象协议（meta-object protocol，缩写为 MOP），因此 Qt 程序还不是标准的 ISO C++ 应用。静态反射使我们最终能够解决这个问题。 C++ 支持多种编程风格（如您坚持，也可以称为“范式”），其背后的想法并不是要让我们选择一种最喜欢的样式进行编程，而是可以将多种风格组合使用，以表达比单一风格更好的解决方案。 当我们需要一个值时，函数是最佳的计算方式，即使——尤其——在编译期。传统模板元编程最好只保留用于计算新的类型和控制结构。 11. 回顾 没有一种语言对所有人和所有事都是完美的。对于这点，没有人比既懂多种语言、又严肃使用其中一种并努力支持它的人了解更多了。 C++ 苦于诞生过早，在现代化的集成开发环境（IDE）、构建系统、图形界面（GUI）系统和 Unicode 问世之前就已经诞生了。 异步的流行、并发/分布式的流行、web 的流行……都应该是推动 C++ 急速进化的主要应用领域，全都错过了。 C++ 社区还缺少一个标准的地方来寻找有用的库。 字符集和图形：C++ 语言和标准库依赖于 ASCII，但大多数应用程序使用某种形式的 Unicode。 字符编码上的混乱真的是劝退级的！ C++ 标准委员会的章程几乎只关注语言和库的设计。这是有局限性的。一直以来，像动态链接、构建系统和静态分析之类的重要主题大多被忽略了。这是个错误。工具是软件开发人员世界的一个重要组成部分，要是能不把它们置于语言设计的外围就好了。 生态！生态！还是生态！","link":"/HOPL4%E7%AC%94%E8%AE%B07-11.html"},{"title":"国外VPS黑白名单","text":"白名单https://vultr.com/ 黑名单 https://flaunt7.com/ 垃圾，会无故下线服务器，各种反馈渠道没有响应。 https://hostus.us/ 不能购买 VPS，直接把我标记为了 fraud（诈骗），要求我提供身份证明信息。 https://www.linode.com/ 同上，说我行为、模式像诈骗。 https://www.time4vps.com/ 同上，需要提供驾驶证、身份证或者护照。","link":"/%E5%9B%BD%E5%A4%96VPS%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95.html"},{"title":"vultr.com 默认开启了 http 防火墙","text":"ubuntu 上安装完 nginx 后发现默认首页不能访问，可以优先检查 ufw 防火墙： 1sudo ufw status 结果显示 status: active，说明 vultr 上的防火墙是默认开启的。 执行命令将 http、https 端口加入到白名单： 12sudo ufw allow 'Nginx HTTP'sudo ufw allow 'Nginx HTTPS' 可以了。 参考：How to Set Up Nginx on a Ubuntu Server with Vultr: https://coderrocketfuel.com/article/how-to-set-up-nginx-on-a-ubuntu-server-with-vultr","link":"/vultr-com%E9%BB%98%E8%AE%A4%E5%BC%80%E5%90%AF%E4%BA%86http%E9%98%B2%E7%81%AB%E5%A2%99.html"},{"title":"React 笔记—核心概念","text":"本文基于官方 v18.1.0 文档。 Introducing JSXWhy JSX? React embraces the fact that rendering logic is inherently coupled with other UI logic:how events are handled, how the state changes over time, and how the data is prepared for display. Instead of artificially separating technologies by putting markup and logic in separate files,React separates concerns with loosely coupled units called “components” that contain both. 这是当初 React 最吸引我的地方，不执著于将 UI 和逻辑分开。MVC 大行其道几十年后，Android 跟 iOS 也都在尝试返濮了。在我实际工作经验中，进行视图子类化定制的出发点往往就是为了将 UI 和其逻辑写在一起。这个需求越靠近业务层就越强烈。 Embedding Expressions in JSX We split JSX over multiple lines for readability. While it isn’t required, when doing this,we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion. Specifying Attributes with JSX Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX, and tabindex becomes tabIndex. JSX Prevents Injection Attacks Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks. Rendering ElementsElements are the smallest building blocks of React apps. Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React Only Updates What’s Necessary React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. Even though we create an element describing the whole UI tree on every tick, only the text node whose contents have changed gets updated by React DOM. Components and PropsRendering a Component Always start component names with a capital letter.React treats components starting with lowercase letters as DOM tags. Props are Read-Only functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs. All React components must act like pure functions with respect to their props. act like, 说的是组件看起来像纯函数——从 props 角度上讲，而不是真正意义上的纯函数。只是强调 props 的不可变性。 State and LifecycleAdding Lifecycle Methods to a Class The componentDidMount() method runs after the component output has been rendered to the DOM. Using State Correctly State Updates May Be AsynchronousBecause this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. 1234// Correctthis.setState((state, props) =&gt; ({ counter: state.counter + props.increment})); Handling Eventsyou cannot return false to prevent default behavior in React. You must call preventDefault explicitly. e is a synthetic event. In JavaScript, class methods are not bound by default. Understanding JavaScript Bind () If calling bind annoys you, there are two ways you can get around this. public class fields syntax 123456789101112131415class LoggingButton extends React.Component { // This syntax ensures `this` is bound within handleClick. // Warning: this is *experimental* syntax. handleClick = () =&gt; { console.log('this is:', this); } render() { return ( &lt;button onClick={this.handleClick}&gt; Click me &lt;/button&gt; ); }} arrow function 1234567891011121314class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // This syntax ensures `this` is bound within handleClick return ( &lt;button onClick={() =&gt; this.handleClick()}&gt; Click me &lt;/button&gt; ); }} The problem with this syntax is that a different callback is created each time the LoggingButton renders. Conditional RenderingPreventing Component from Rendering In rare cases you might want a component to hide itself even though it was rendered by another component.To do this return null instead of its render output. Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods.For instance componentDidUpdate will still be called. Lists and KeysKeys We don’t recommend using indexes for keys if the order of items may change.This can negatively impact performance and may cause issues with component state. If you choose not to assign an explicit key to list items then React will default to using indexes as keys. FormsControlled Components In HTML, form elements such as &lt;input&gt;, &lt;textarea&gt;, and &lt;select&gt; typically maintain their own state and update it based on user input.In React, mutable state is typically kept in the state property of components, and only updated with setState(). We can combine the two by making the React state be the “single source of truth”.Then the React component that renders a form also controls what happens in that form on subsequent user input.An input form element whose value is controlled by React in this way is called a “controlled component”. 受控组件。简单说就是表单类 HTML 元素的 value 显示被 React 组件接管、控制了。 The textarea Tag In HTML, a &lt;textarea&gt; element defines its text by its children: 123&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt; In React, a &lt;textarea&gt; uses a value attribute instead. The select Tag React, instead of using this selected attribute, uses a value attribute on the root select tag. You can pass an array into the value attribute, allowing you to select multiple options in a select tag. The file input Tag Because its value is read-only, it is an uncontrolled component in React. Handling Multiple Inputs Note how we used the ES6 computed property name syntax to update the state key corresponding to the given input name: 123this.setState({ [name]: value}); Computed property name: 计算属性名。把方括号内的表达式所表示的字符串值作为属性名。 Lifting State UpLifting State Up In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. Composition vs InheritanceContainment Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”. We recommend that such components use the special children prop to pass children elements directly into their output. While this is less common, sometimes you might need multiple “holes” in a component. In such cases you may come up with your own convention instead of using children: 123456789101112131415161718192021222324function SplitPane(props) { return ( &lt;div className=&quot;SplitPane&quot;&gt; &lt;div className=&quot;SplitPane-left&quot;&gt; {props.left} &lt;/div&gt; &lt;div className=&quot;SplitPane-right&quot;&gt; {props.right} &lt;/div&gt; &lt;/div&gt; );}function App() { return ( &lt;SplitPane left={ &lt;Contacts /&gt; } right={ &lt;Chat /&gt; } /&gt; );} So What About Inheritance? Remember that components may accept arbitrary props, including primitive values, React elements, or functions. Thinking in ReactUse the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.","link":"/React%E7%AC%94%E8%AE%B0%E2%80%94%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html"},{"title":"React 笔记—高级指引","text":"本文基于官方 v18.1.0 文档。 Code-SplittingCode Splitting You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load. Code-Splitting is a feature supported by bundlers like Webpack, Rollup and Browserify (via factor-bundle) which can create multiple bundles that can be dynamically loaded at runtime. Code-splitting your app can help you “lazy-load” just the things that are currently needed by the user, which can dramatically improve the performance of your app. import() The best way to introduce code-splitting into your app is through the dynamic import() syntax. When Webpack comes across this syntax, it automatically starts code-splitting your app. React.lazy React 提供的一种异步动态加载机制。用 React.lazy 导入组件，然后在 Suspense 组件中使用组件。 The fallback prop accepts any React elements that you want to render while waiting for the component to load. Avoiding fallbacks 介绍了 React 18 中并发特性 Transition 的一种用法，使用 startTransition 避免显示 fallback。 Route-based code splitting 一种基于路由拆分 bundle 的思路。用到了 React.lazy 和 React Router。 Named Exports React.lazy currently only supports default exports. If the module you want to import uses named exports, you can create an intermediate module that reexports it as the default. ContextContext provides a way to pass data through the component tree without having to pass props down manually at every level. Error BoundariesIntroducing Error Boundaries Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries do not catch errors for: Event handlers Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks) Server side rendering Errors thrown in the error boundary itself (rather than its children) A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown. Use componentDidCatch() to log error information. Only class components can be error boundaries. New Behavior for Uncaught Errors As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree. React 16 起，未捕获错误会导致整个 React 组件树被卸载。 …it is worse to leave corrupted UI in place than to completely remove it. How About try/catch? try / catch 只适用于命令式代码，而基于 jsx 的 React 是声明式的。 How About Event Handlers? Error boundaries do not catch errors inside event handlers. 错误边界仅负责 React 组件本身的错误处理，比如 render 方法、其它生命周期方法。 Forwarding RefsRef forwarding is a technique for automatically passing a ref through a component to one of its children. Ref forwarding is not limited to DOM components. You can forward refs to class component instances, too. 大致上就是，有时候组件使用者想获取组件内层某个 DOM 元素或子组件的 ref，因为 ref is not available in props，必须使用 React.forwardRef 创建组件，将 ref 作为函数参数传递到组件内部。 即，正常创建的组件 &lt;FancyButton ref={ref} /&gt;，那 ref 一定是指向 FancyButton 的；而如果此组件是通过 React.forwardRef 创建，ref 就有可能指向内部元素。 这似乎意义不大啊，虽然 ref 是保留字，我依然可以换用其它更有意义的 prop 名字通过普通组件达到相同的目的，比如 &lt;FancyButton innerButtonRef={ref} /&gt;。而且 ref 转发只适用于函数组件，不能用于类组件。 似乎只是提供了一种可以不修改接口就可以改变行为的手段，对组件库开发者比较有用？ FragmentsFragments let you group a list of children without adding extra nodes to the DOM. Keyed Fragments Fragments declared with the explicit &lt;React.Fragment&gt; syntax may have keys. 短语法不能有属性。 Higher-Order ComponentsA higher-order component is a function that takes a component and returns a new component. Use HOCs For Cross-Cutting Concerns 横切关注点指的是一些具有横越多个模块的行为。 高阶组件用来解决多组具有同一类切面导致的重复代码的问题。可以将形成切面关系的两者通过另一个更高阶的组件封装，将横切关注点放在高阶组件内。 A HOC is a pure function with zero side-effects. Don’t Mutate the Original Component. Use Composition. Convention: Pass Unrelated Props Through to the Wrapped Component HOCs add features to a component. They shouldn’t drastically alter its contract. It’s expected that the component returned from a HOC has a similar interface to the wrapped component. Static Methods Must Be Copied Over 在 HOC 返回前必须把 wrappedComponent 的所有静态方法复制到容器组件中，否则用户通过高阶组件调用不到这些静态方法。 However, this requires you to know exactly which methods need to be copied. You can use hoist-non-react-statics to automatically copy all non-React static methods. Integrating with Other Libraries 以 jQuery 和 backbone.js 为例，详述了如何将 React 同其它库集成。略过没看。 JSX In DepthSpecifying The React Element Type Capitalized types indicate that the JSX tag is referring to a React component. React 组件名称必须大写字母开头。 React Must Be in Scope Since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code. 只要用到了 React 组件，就要 import React from 'react'; If you don’t use a JavaScript bundler and loaded React from a &lt;script&gt; tag, it is already in scope as the React global. Choosing the Type at Runtime You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. JavaScript Expressions as Props if statements and for loops are not expressions in JavaScript, so they can’t be used in JSX directly. String Literals When you pass a string literal, its value is HTML-unescaped. 即 &lt;MyComponent message=&quot;&amp;lt;3&quot; /&gt; 这种会先被转义。 Props Default to “True” If you pass no value for a prop, it defaults to true. In general, we don’t recommend not passing a value for a prop, because it can be confused with the ES6 object shorthand {foo} which is short for {foo: foo} rather than {foo: true}. Spread Attributes You can also pick specific props that your component will consume while passing all other props using the spread syntax. 12345const Button = props =&gt; { const { kind, ...other } = props; const className = kind === &quot;primary&quot; ? &quot;PrimaryButton&quot; : &quot;SecondaryButton&quot;; return &lt;button className={className} {...other} /&gt;;}; 变量 other 的定义。 Children in JSX In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. Functions as Children props.children works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. Booleans, Null, and Undefined Are Ignored false, null, undefined, and true are valid children. They simply don’t render. Optimizing PerformanceVirtualize Long Lists 使用一些第三方虚拟列表库： react-window react-virtualized Avoid Reconciliation In most cases, instead of writing shouldComponentUpdate() by hand, you can inherit from React.PureComponent. It is equivalent to implementing shouldComponentUpdate() with a shallow comparison of current and previous props and state. The Power Of Not Mutating Data 因为 React.PureComponent 做的是浅比较，所以要避免修改 object 类型的 state 或 prop 的值。可以通过展开操作符或 object.assign 等方法每次创建新对象赋值给 state / prop。 PortalsPortals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. Usage 12345678render() { // React does *not* create a new div. It renders the children into `domNode`. // `domNode` is any valid DOM node, regardless of its location in the DOM. return ReactDOM.createPortal( this.props.children, domNode );} Event Bubbling Through Portals This includes event bubbling. An event fired from inside a portal will propagate to ancestors in the containing React tree, even if those elements are not ancestors in the DOM tree. Profiler APIonRender Callback 1234567891011function onRenderCallback( id, // the &quot;id&quot; prop of the Profiler tree that has just committed phase, // either &quot;mount&quot; (if the tree just mounted) or &quot;update&quot; (if it re-rendered) actualDuration, // time spent rendering the committed update baseDuration, // estimated time to render the entire subtree without memoization startTime, // when React began rendering this update commitTime, // when React committed this update interactions // the Set of interactions belonging to this update) { // Aggregate or log render timings...} React Without ES6 略过。 React Without JSX 略过。 ReconciliationMotivation React implements a heuristic O(n) algorithm based on two assumptions: Two elements of different types will produce different trees. The developer can hint at which child elements may be stable across different renders with a key prop. Elements Of Different Types Whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch. DOM Elements Of The Same Type When comparing two React DOM elements of the same type, React looks at the attributes of both, keeps the same underlying DOM node, and only updates the changed attributes. When updating style, React also knows to update only the properties that changed. Recursing On Children By default, when recursing on the children of a DOM node, React just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference. If you implement it naively, inserting an element at the beginning has worse performance. 如果没有 key，React 就无脑地迭代比较每一子项——即用索引匹配比较项。所以如果在索引 0 处新插入了项，React 会认为自 0 开始的每一项都改变了，而不认为只是新加了一项。借此说明 key 的必要性。 Keys When children have keys, React uses the key to match children in the original tree with children in the subsequent tree. key 只对 children 生效。 Reorders can also cause issues with component state when indexes are used as keys. 如果用索引做 key，重排序时比较项会错乱。 Tradeoffs 呼应开头的两个假设。为了能获得最好的性能，尽量使用同一种组件/元素类型；尽量使用稳定、可预测、唯一的 key 值。 Refs and the DOMAccessing Refs You may not use the ref attribute on function components because they don’t have instances. Adding a Ref to a DOM Element ref updates happen before componentDidMount or componentDidUpdate lifecycle methods. Refs and Function Components If you want to allow people to take a ref to your function component, you can use forwardRef. 承上文，ref 不能指向函数组件。 Callback Refs ref 属性还支持接受一个函数作为参数值。函数接受一个指向当前组件/元素的参数。这时候就不需要 createRef 了，用普通的成员变量保存参数即可。 Caveats with callback refs If the ref callback is defined as an inline function, it will get called twice during updates, first with null and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. Render PropsThe term “render prop” refers to a technique for sharing code between React components using a prop whose value is a function. Use Render Props for Cross-Cutting Concerns More concretely, a render prop is a function prop that a component uses to know what to render. Using Props Other Than render In fact, any prop that is a function that a component uses to know what to render is technically a “render prop”. children 也是。但是 children 还比较特殊，支持把函数定义放在组件内部。 上边 3 句话逐渐接近 render prop 的本质。 Be careful when using Render Props with React.PureComponent 内联函数传递的通病——每次渲染都会认为是新创建的函数。解决方法也是一样，改为组件类的实例方法。 Static Type Checking 介绍了 Flow、TypeScript 等几种静态检查工具、语言。略。 Strict ModeStrict mode checks are run in development mode only; they do not impact the production build. StrictMode currently helps with: Identifying unsafe lifecycles Warning about legacy string ref API usage Warning about deprecated findDOMNode usage Detecting unexpected side effects Conceptually, React does work in two phases: The render phase determines what changes need to be made to e.g. the DOM. During this phase, React calls render and then compares the result to the previous render. The commit phase is when React applies any changes. (In the case of React DOM, this is when React inserts, updates, and removes DOM nodes.) React also calls lifecycles like componentDidMount and componentDidUpdate during this phase. 这章节信息量很大。列出了 render 阶段具体有哪些生命周期方法；v18 引入的并发模式有可能会导致多次调用 render 阶段的生命周期方法；严格模式会故意地两次调用这些生命周期方法以帮助识别非幂等代码导致的问题等。 Detecting legacy context API Ensuring reusable state In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. 为了支持这个 feature，React 要多次 mount、unmount 组件，StrictMode 会人为地 unmount 然后重新 mount 组件以测试组件，发现问题。 Typechecking With PropTypesTo run typechecking on the props for a component, you can assign the special propTypes property. PropTypes exports a range of validators that can be used to make sure the data you receive is valid. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. For performance reasons, propTypes is only checked in development mode. Requiring Single Child 123MyComponent.propTypes = { children: PropTypes.element.isRequired}; MyComponent 只能包含一个元素。 Default Prop Values 123Greeting.defaultProps = { name: 'Stranger'}; name prop 的默认值是 Stranger。 Function Components 必须在 export 之前定义 propTypes，所以要把 export default function 分开两句，中间定义 propTypes 属性。 Uncontrolled ComponentsDefault Values Changing the value of defaultValue attribute after a component has mounted will not cause any update of the value in the DOM. The file input Tag In React, an &lt;input type=&quot;file&quot; /&gt; is always an uncontrolled component because its value can only be set by a user, and not programmatically. Web ComponentsReact and Web Components are built to solve different problems. Web Components provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data.","link":"/React%E7%AC%94%E8%AE%B0%E2%80%94%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95.html"},{"title":"React 笔记— Hooks","text":"本文基于官方 v18.1.0 文档。 Introducing HooksThey let you use state and other React features without writing a class. Motivation It’s hard to reuse stateful logic between components 现在可以通过自定义 Hook 提取封装带状态的逻辑。 Complex components become hard to understand useEffect 可以把复杂逻辑分拆到多个小的函数中。 Classes confuse both people and machines Hooks at a GlanceState Hook 解构赋值语法 React assumes that if you call useState many times, you do it in the same order during every render. Effect Hook It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount in React classes, but unified into a single API. Rules of Hooks Only call Hooks at the top level. Don’t call Hooks inside loops, conditions, or nested functions. Only call Hooks from React function components. Don’t call Hooks from regular JavaScript functions. Building Your Own Hooks The state of each component is completely independent. Hooks are a way to reuse stateful logic, not state itself. In fact, each call to a Hook has a completely isolated state — so you can even use the same custom Hook twice in one component. Custom Hooks are more of a convention than a feature. If a function’s name starts with ”use” and it calls other Hooks, we say it is a custom Hook. Using the State HookUsing the Effect Hookyou can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined. Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects. Experienced JavaScript developers might notice that the function passed to useEffect is going to be different on every render. This is intentional….Every time we re-render, we schedule a different effect, replacing the previous one. Unlike componentDidMount or componentDidUpdate, effects scheduled with useEffect don’t block the browser from updating the screen. React performs the cleanup when the component unmounts….React also cleans up effects from the previous render before running the effects next time. Tip: Optimizing Performance by Skipping Effects If you use this optimization, make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect. Rules of HooksOnly Call Hooks at the Top LevelDon’t call Hooks inside loops, conditions, or nested functions. Only Call Hooks from React FunctionsDon’t call Hooks from regular JavaScript functions. Explanation So how does React know which state corresponds to which useState call? The answer is that React relies on the order in which Hooks are called. Building Your Own HooksA custom Hook is a JavaScript function whose name starts with ”use” and that may call other Hooks. Hooks API ReferenceuseState Lazy initial state If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render. Batching of state updates Before React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. In the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in flushSync. However, this can hurt performance so do this only where needed. 12345// Force this state update to be synchronous.flushSync(() =&gt; { setCount(count + 1);});// By this point, DOM is updated. useEffect …the previous effect is cleaned up before executing the next effect. Timing of effects …the function passed to useEffect fires after layout and paint, during a deferred event. 就是前边说的，effects scheduled with useEffect don’t block the browser from updating the screen. useEffect 不阻塞屏幕刷新。 However, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. 之前的解决方案就是 useLayoutEffect，18+ 又多了上边提到的 flushSync。 Conditionally firing an effect …make sure the array includes all values from the component scope (such as props and state) that change over time and that are used by the effect. useContext 1const value = useContext(MyContext); Accepts a context object (the value returned from React.createContext) and returns the current context value for that context. The current context value is determined by the value prop of the nearest &lt;MyContext.Provider&gt; above the calling component in the tree. useContext(MyContext) only lets you read the context and subscribe to its changes. You still need a &lt;MyContext.Provider&gt; above in the tree to provide the value for this context. useReducer 1const [state, dispatch] = useReducer(reducer, initialArg, init); An alternative to useState. Accepts a reducer of type (state, action) =&gt; newState, and returns the current state paired with a dispatch method. 1234567891011121314151617181920212223const initialState = {count: 0};function reducer(state, action) { switch (action.type) { case 'increment': return {count: state.count + 1}; case 'decrement': return {count: state.count - 1}; default: throw new Error(); }}function Counter() { const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: {state.count} &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt; &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt; &lt;/&gt; );} Lazy initialization …you can pass an init function as the third argument. The initial state will be set to init(initialArg). useCallback 123456const memoizedCallback = useCallback( () =&gt; { doSomething(a, b); }, [a, b],); useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed. useCallback(fn, deps) is equivalent to useMemo(() =&gt; fn, deps). useMemo 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); useMemo will only recompute the memoized value when one of the dependencies has changed. If no array is provided, a new value will be computed on every render. useRef useRef() is useful for more than the ref attribute. useRef 实际就是返回了一个 js object，只不过生命周期是持续整个组件生命周期的，所以除了用于 ref，任何其它需要的场景都可以用。 useImperativeHandle 1useImperativeHandle(ref, createHandle, [deps]) 自定义 ref.current 的值。createHandle 的结果对象作为 ref.current 的新值。 useImperativeHandle should be used with forwardRef. useLayoutEffect 同 useEffect 作用，但是触发时机、对 DOM 的更新都是同步的、阻塞的。 useDebugValue useDebugValue can be used to display a label for custom hooks in React DevTools. useDeferredValue 1const deferredValue = useDeferredValue(value); 将 value 记忆化。碰到 urgent 更新时，会用旧值渲染；非 urgent 时，以新值渲染。跟防抖不同，useDeferredValue 保证最后一定会以新值渲染一次。所以 useDeferredValue 有可能会触发两次渲染。 细节参考：https://github.com/reactwg/react-18/discussions/129 useTransition 1const [isPending, startTransition] = useTransition(); Returns a stateful value for the pending state of the transition, and a function to start it. Updates in a transition yield to more urgent updates such as clicks. 将一个函数调用变为转场。回调函数会至少延迟一个渲染周期后被调用。React 把更新分成两类：Urgent 和 Transition。转场是可以 pending 的，startTransition 被调用到回调函数被调用前，isPending 为 true。 细节参考：https://github.com/reactwg/react-18/discussions/41 useId 生成一个唯一字符串。 Hooks FAQ How can I measure a DOM node? 元素大小不变的情况下不需要 ResizeObserver，用 callback ref。妙啊！ 12345678910111213141516 function MeasureExample() { const [height, setHeight] = useState(0); const measuredRef = useCallback(node =&gt; { if (node !== null) { setHeight(node.getBoundingClientRect().height); } }, []); return ( &lt;&gt; &lt;h1 ref={measuredRef}&gt;Hello, world&lt;/h1&gt; &lt;h2&gt;The above header is {Math.round(height)}px tall&lt;/h2&gt; &lt;/&gt; );} How do I implement shouldComponentUpdate? You can wrap a function component with React.memo to shallowly compare its props: 123 const Button = React.memo((props) =&gt; { // your component}); How to memoize calculations? The useMemo Hook lets you cache calculations between multiple renders by “remembering” the previous computation: 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); Conveniently, useMemo also lets you skip an expensive re-render of a child: 123456789101112 function Parent({ a, b }) { // Only re-rendered if `a` changes: const child1 = useMemo(() =&gt; &lt;Child1 a={a} /&gt;, [a]); // Only re-rendered if `b` changes: const child2 = useMemo(() =&gt; &lt;Child2 b={b} /&gt;, [b]); return ( &lt;&gt; {child1} {child2} &lt;/&gt; )} How to create expensive objects lazily? 12345 function Table(props) { // ⚠️ createRows() is called on every render const [rows, setRows] = useState(createRows(props.count)); // ...} To avoid re-creating the ignored initial state, we can pass a function to useState: 12345 function Table(props) { // ✅ createRows() is only called once const [rows, setRows] = useState(() =&gt; createRows(props.count)); // ...}","link":"/React%E7%AC%94%E8%AE%B0%E2%80%94Hooks.html"},{"title":"Unity 垃圾收集最佳实践","text":"前言最近在搞的一个 Unity 项目是以插件形式运行在服务端的，对内存碎片问题有比较高的要求，正好有机会深入学习了下 Unity 的 GC。这篇文章便是从 Unity 2019.4 官方文档 Garbage collection best practices 翻译、摘要而来。 正文自动内存管理让你写起代码时又快又简单，还能减少出错。但是这种便利有可能带来性能影响。为了优化代码以提高性能，你必须避免频繁触发 GC 的情形。 情形一：临时分配为每一帧在托管堆上分配临时数据。例如： 如果每帧申请 1KB 的临时内存，每秒 60 帧，那么每秒会产生 60KB 的临时内存。每分钟就是 3.6MB 内存需要 GC。 每秒调用一次 GC 就会对性能产生负面影响。但是如果每分钟仅运行一次 GC，就要一次性清除不连续的 3.6MB 内存，这会导致显著的 GC 时间。 加载操作对性能有影响。如果在一个很重的资产加载操作期间生成大量临时对象，Unity 又一直引用它们直到操作完成，那么 GC 就不能及时释放这些临时对象。这意味着托管堆需要扩大——即使 Unity 会在短时间后释放大量对象。 你需要尝试尽可能地降低内存分配次数以避开此种情况：理想情况下是每帧分配 0 字节的临时对象，或者尽可能地接近于 0。 解法一：可复用的对象池以子弹为例，没必要每次都从 prefab 实例化一个新的子弹对象。可以预先计算出屏幕上最多可显示的子弹数量，然后在首次进入场景时申请此数量的一组对象。 情形二：反复的字符串拼接string 类在 C# 里是不可变引用类型。引用类型意味着 Unity 在托管堆上分配它们并且服从于 GC。不可变意味着 string 对象一旦创建就不能再被修改；任何视图修改字符串的行为都会产生一个新的字符串对象。所以你应该尽可能地避免创建临时字符串。 对大量的拼接应该使用 StringBuilder 类。 除非是拼接非常频繁，比如每一帧都会，一般的字符串拼接不会太多地降低性能。 情形三：返回数组的方法解法三：复用集合和数组复用 System.Collection 命名空间中的数组或类是很高效的。集合类暴露了一个 Clear 方法，清除集合元素但是不释放集合分配的内存。（即集合中元素的引用会被减 1，如果元素对象引用归 0 则被释放；但是集合本身的容量不变。跟 C++ 中 vector 行为一样。） 情形四：闭包和匿名方法通常来说：在 C# 里你应该尽可能地避免闭包；你应该最小化在性能敏感代码里对匿名函数和函数引用的使用，特别是那些每一帧都会执行的代码。 方法引用是一种引用类型，在堆上分配。这意味着如果你把方法引用用作一个方法实参，很容易就创建出了临时分配。这种分配不管被传递的方法是匿名的还是具名的都会发生。 另外，当把匿名方法转换成闭包时，把闭包当做参数传递给方法所需的内存总量会增加很多。（大概意思就是闭包比匿名函数更占内存？） 为了能把值传递进闭包，C# 会生成一个持有闭包所需的外部作用域的变量的匿名类。当把闭包作为参数传递给方法时，会实例化这个匿名类。 情形五：装箱应该避免装箱。 情形六：数组值的 Unity API1234567891011121314// Bad C# script example: this loop create 4 copies of the vertices array per iterationvoid Update() { for(int i = 0; i &lt; mesh.vertices.Length; i++) { // mesh.vertices 会创建临时对象 float x, y, z; x = mesh.vertices[i].x; // mesh.vertices[i] 会创建临时对象 y = mesh.vertices[i].y; // mesh.vertices[i] 会创建临时对象 z = mesh.vertices[i].z; // mesh.vertices[i] 会创建临时对象 // ... DoSomething(x, y, z); }} 每次迭代创建 4 个临时对象。 后记每秒调用一次 GC 就会对性能产生负面影响（Invoking the garbage collector once per second has a negative effect on performance.）。这结论对我太震撼了。 本来只想知道频繁 GC 对内存碎片化的影响大小，看来即便只考虑性能问题，该做的优化还是得做啊。","link":"/Unity%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html"}],"tags":[{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"并行&#x2F;并发计算","slug":"并行-并发计算","link":"/tags/%E5%B9%B6%E8%A1%8C-%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/"},{"name":"AVX2","slug":"AVX2","link":"/tags/AVX2/"},{"name":"C++17","slug":"C-17","link":"/tags/C-17/"},{"name":"NEON","slug":"NEON","link":"/tags/NEON/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"VR","slug":"VR","link":"/tags/VR/"},{"name":"mono","slug":"mono","link":"/tags/mono/"},{"name":"Animator","slug":"Animator","link":"/tags/Animator/"},{"name":"Qt","slug":"Qt","link":"/tags/Qt/"},{"name":"VideoPlayer","slug":"VideoPlayer","link":"/tags/VideoPlayer/"},{"name":"XOPlayer","slug":"XOPlayer","link":"/tags/XOPlayer/"},{"name":"西安","slug":"西安","link":"/tags/%E8%A5%BF%E5%AE%89/"},{"name":"DeepSpeech","slug":"DeepSpeech","link":"/tags/DeepSpeech/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Spectre","slug":"Spectre","link":"/tags/Spectre/"},{"name":"FFmpeg","slug":"FFmpeg","link":"/tags/FFmpeg/"},{"name":"NAS","slug":"NAS","link":"/tags/NAS/"},{"name":"Jellyfin","slug":"Jellyfin","link":"/tags/Jellyfin/"},{"name":"Video.js","slug":"Video-js","link":"/tags/Video-js/"},{"name":"Sanic","slug":"Sanic","link":"/tags/Sanic/"},{"name":"MP4","slug":"MP4","link":"/tags/MP4/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"国外VPS","slug":"国外VPS","link":"/tags/%E5%9B%BD%E5%A4%96VPS/"}],"categories":[{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"FFmpeg","slug":"FFmpeg","link":"/categories/FFmpeg/"},{"name":"StreamingCore","slug":"StreamingCore","link":"/categories/StreamingCore/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"并发计算","slug":"C/并发计算","link":"/categories/C/%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97/"},{"name":"FFmpeg 常用命令","slug":"FFmpeg-常用命令","link":"/categories/FFmpeg-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"智能家居","slug":"智能家居","link":"/categories/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/"},{"name":"C++17","slug":"C/C-17","link":"/categories/C/C-17/"},{"name":"C++17详解","slug":"C/C-17/C-17详解","link":"/categories/C/C-17/C-17%E8%AF%A6%E8%A7%A3/"},{"name":"MP4","slug":"MP4","link":"/categories/MP4/"},{"name":"SmartHome","slug":"智能家居/SmartHome","link":"/categories/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/SmartHome/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"React","slug":"Web/React","link":"/categories/Web/React/"},{"name":"Python","slug":"Web/Python","link":"/categories/Web/Python/"},{"name":"Sanic","slug":"Web/Python/Sanic","link":"/categories/Web/Python/Sanic/"},{"name":"Qt","slug":"C/Qt","link":"/categories/C/Qt/"},{"name":"使用 Unity 开发 Android VR 应用","slug":"Unity/使用-Unity-开发-Android-VR-应用","link":"/categories/Unity/%E4%BD%BF%E7%94%A8-Unity-%E5%BC%80%E5%8F%91-Android-VR-%E5%BA%94%E7%94%A8/"},{"name":"HOPL4","slug":"C/HOPL4","link":"/categories/C/HOPL4/"},{"name":"Docs","slug":"Web/React/Docs","link":"/categories/Web/React/Docs/"}]}